<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-10T22:35:45+08:00</updated><id>http://localhost:4000/</id><title type="html">赵志富的个人网站 | 无聊才读书</title><subtitle>生于黄龙府，苟活阿勒锦。弱冠入前端，学浅而空迟。吾今用博客，以书所思想。日后若有暇，温故求知新。</subtitle><author><name>true</name></author><entry><title type="html">yarn 安装与使用</title><link href="http://localhost:4000/2020/02/04/Yarn-installation-and-use.html" rel="alternate" type="text/html" title="yarn 安装与使用" /><published>2020-02-04T20:01:00+08:00</published><updated>2020-02-04T20:01:00+08:00</updated><id>http://localhost:4000/2020/02/04/Yarn-installation-and-use</id><content type="html" xml:base="http://localhost:4000/2020/02/04/Yarn-installation-and-use.html">&lt;p&gt;&lt;img src=&quot;../assets/blogImg/20200204.png&quot; alt=&quot;yarn包管理器&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1---introduction&quot;&gt;1 - Introduction&lt;/h1&gt;

&lt;p&gt;Yarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码， 或者分享自己的代码。yarn可以快速、安全、可靠地做到这一点，所以你永远不必担心。&lt;/p&gt;

&lt;p&gt;通过Yarn你可以使用其他开发者针对不同问题的解决方案，使自己的开发过程更简单。&lt;/p&gt;

&lt;p&gt;代码通过 包（package） (或者称为 模块（module）) 的方式来共享。 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 package.json 。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h1 id=&quot;2---installation&quot;&gt;2 - Installation&lt;/h1&gt;

&lt;p&gt;注意：当前，Yarn 2仅可通过npm安装。以前在Yarn 1中可用的安装方法（Windows安装程序，Chocolatey，Debian / Ubuntu软件包，Homebrew和RPM软件包）将很快再次可用。&lt;/p&gt;

&lt;p&gt;1.安装Node.js&lt;/p&gt;

&lt;p&gt;2.安装yarn&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install -g yarn@berry&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.通过运行以下命令测试Yarn 2是否已正确安装，其结果应为“ v2.0.0”或类似的结果：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn --version&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;每个项目的安装&quot;&gt;每个项目的安装&lt;/h2&gt;

&lt;p&gt;1.遵循全局安装说明&lt;/p&gt;

&lt;p&gt;2.移至您的项目文件夹：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/path/to/project&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.运行以下命令：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn set version berry&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4.提交.yarn和.yarnrc.yml更改&lt;/p&gt;

&lt;h1 id=&quot;3---usage&quot;&gt;3 - Usage&lt;/h1&gt;

&lt;p&gt;现在，您已经安装了 Yarn ，可以开始使用Yarn了。这是您需要的一些最常见的命令。&lt;/p&gt;

&lt;p&gt;访问命令列表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn help&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;开始一个新项目&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装所有依赖项&lt;/p&gt;

&lt;p&gt;yarn
&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加依赖&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add [package]
yarn add [package]@[version]
yarn add [package]@[tag]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将依赖项添加到不同类别的依赖项中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add [package] --dev  # dev dependencies
yarn add [package] --peer # peer dependencies
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;升级依赖&lt;/p&gt;

&lt;p&gt;yarn up [package]
yarn up [package]@[version]
yarn up [package]@[tag]&lt;/p&gt;

&lt;p&gt;删除依赖&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn remove [package]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;升级yarn本身&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn set version 2.0.0&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn set version from sources&lt;/code&gt;&lt;/p&gt;</content><author><name>true</name></author><category term="yarn" /><category term="包管理器" /><summary type="html"></summary></entry><entry><title type="html">uni-app 跨平台框架学习笔记【一】</title><link href="http://localhost:4000/2020/01/14/Learning-notes-of-uni-app-cross-platform-framework.html" rel="alternate" type="text/html" title="uni-app 跨平台框架学习笔记【一】" /><published>2020-01-14T17:43:22+08:00</published><updated>2020-01-14T17:43:22+08:00</updated><id>http://localhost:4000/2020/01/14/Learning-notes-of-uni-app-cross-platform-framework</id><content type="html" xml:base="http://localhost:4000/2020/01/14/Learning-notes-of-uni-app-cross-platform-framework.html">&lt;p&gt;&lt;img src=&quot;../assets/blogImg/201001141036.jpg&quot; alt=&quot;uni-app学习笔记&quot; /&gt;&lt;/p&gt;

&lt;p&gt;uni-app 是一个使用 Vue.js 开发所有前端应用的框架，&lt;/p&gt;

&lt;p&gt;开发者编写一套代码，可发布到iOS、Android、H5、&lt;/p&gt;

&lt;p&gt;以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。&lt;/p&gt;

&lt;p&gt;uni-app 使用vue的语法+小程序的标签和API。功能架构如下图：
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/blogImg/202001141040.png&quot; alt=&quot;uni-app功能框架图&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;uni-app-约定了如下开发规范&quot;&gt;uni-app 约定了如下开发规范：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;页面文件遵循 Vue &lt;a href=&quot;https://vue-loader.vuejs.org/zh/spec.html#%E7%AE%80%E4%BB%8B&quot;&gt;单文件组件 (SFC) 规范&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;组件标签靠近小程序规范，详见&lt;a href=&quot;https://uniapp.dcloud.io/component/README&quot;&gt;官网uni-app 组件规范&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;接口能力（JS API）靠近微信小程序规范，但需将前缀 wx 替换为 uni，详见uni-app接口规范&lt;/li&gt;
  &lt;li&gt;数据绑定及事件处理同 Vue.js 规范，同时补充了App及页面的生命周期&lt;/li&gt;
  &lt;li&gt;为兼容多端运行，建议使用flex布局进行开发&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;

&lt;p&gt;一个uni-app工程，默认包含如下目录及文件：&lt;/p&gt;

&lt;p&gt;┌─components            uni-app组件目录
│  └─comp-a.vue         可复用的a组件
├─hybrid                存放本地网页的目录
├─platforms             存放各平台专用页面的目录
├─pages                 业务页面文件存放的目录
│  ├─index
│  │  └─index.vue       index页面
│  └─list
│     └─list.vue        list页面
├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此
├─wxcomponents          存放小程序组件的目录
├─main.js               Vue初始化入口文件
├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期
├─manifest.json         配置应用名称、appid、logo、版本等打包信息
└─pages.json            配置页面路由、导航条、选项卡等页面类信息&lt;/p&gt;

&lt;p&gt;注意：
    static 目录下的 js 文件不会被编译，如果里面有 es6 的代码，不经过转换直接运行，在手机设备上会报错。
    css、less/scss 等资源同样不要放在 static 目录下，建议这些公用的资源放在 common 目录下。&lt;/p&gt;

&lt;h2 id=&quot;生命周期&quot;&gt;生命周期&lt;/h2&gt;

&lt;h3 id=&quot;应用生命周期&quot;&gt;应用生命周期&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;onLaunch&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当uni-app 初始化完成时触发（全局只触发一次）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onShow&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当 uni-app 启动，或从后台进入前台显示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onHide&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当 uni-app 从前台进入后台&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onError&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当 uni-app 报错时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onUniNViewMessage&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;页面生命周期&quot;&gt;页面生命周期&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;onLoad	监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参）&lt;/li&gt;
  &lt;li&gt;onShow	监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面&lt;/li&gt;
  &lt;li&gt;onReady	监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发&lt;/li&gt;
  &lt;li&gt;onHide	监听页面隐藏&lt;/li&gt;
  &lt;li&gt;onUnload	监听页面卸载&lt;/li&gt;
  &lt;li&gt;onResize	监听窗口尺寸变化&lt;/li&gt;
  &lt;li&gt;onPullDownRefresh	监听用户下拉动作，一般用于下拉刷新&lt;/li&gt;
  &lt;li&gt;onReachBottom	页面上拉触底事件的处理函数&lt;/li&gt;
  &lt;li&gt;onTabItemTap	点击 tab 时触发，参数为Object，具体见官方文档&lt;/li&gt;
  &lt;li&gt;onShareAppMessage	用户点击右上角分享&lt;/li&gt;
  &lt;li&gt;onPageScroll	监听页面滚动，参数为Object&lt;/li&gt;
  &lt;li&gt;onNavigationBarButtonTap	监听原生标题栏按钮点击事件，参数为Object&lt;/li&gt;
  &lt;li&gt;onBackPress	监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：onBackPress 详解&lt;/li&gt;
  &lt;li&gt;onNavigationBarSearchInputChanged	监听原生标题栏搜索输入框输入内容变化事件&lt;/li&gt;
  &lt;li&gt;onNavigationBarSearchInputConfirmed	监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。&lt;/li&gt;
  &lt;li&gt;onNavigationBarSearchInputClicked	监听原生标题栏搜索输入框点击事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;路由&quot;&gt;路由&lt;/h2&gt;

&lt;p&gt;uni-app页面路由为框架统一管理，开发者需要在pages.json里配置每个路由页面的路径及页面样式。类似小程序在app.json中配置页面路由一样。所以 uni-app 的路由用法与 Vue Router 不同，如仍希望采用 Vue Router 方式管理路由，可在插件市场搜索 Vue-Router。&lt;/p&gt;

&lt;h3 id=&quot;路由跳转&quot;&gt;路由跳转&lt;/h3&gt;
&lt;p&gt;uni-app 有两种页面路由跳转方式：使用navigator组件跳转、调用API跳转。&lt;/p&gt;

&lt;h2 id=&quot;运行环境判断&quot;&gt;运行环境判断&lt;/h2&gt;
&lt;p&gt;开发环境和生产环境
uni-app 可通过 process.env.NODE_ENV 判断当前环境是开发环境还是生产环境。一般用于连接测试服务器或生产服务器的动态切换。&lt;/p&gt;

&lt;p&gt;cli模式下，是通行的编译环境处理方式。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(process.env.NODE_ENV === 'development'){
    console.log('开发环境')
}else{
    console.log('生产环境')
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;页面样式与布局&quot;&gt;页面样式与布局&lt;/h2&gt;</content><author><name>true</name></author><category term="微信小程序" /><category term="跨平台框架" /><category term="uni-app" /><summary type="html"></summary></entry><entry><title type="html">身份证最后一位校验算法(ISO 7064:1983.MOD 11-2)</title><link href="http://localhost:4000/2019/12/18/ISO-7064.html" rel="alternate" type="text/html" title="身份证最后一位校验算法(ISO 7064:1983.MOD 11-2)" /><published>2019-12-18T19:35:20+08:00</published><updated>2019-12-18T19:35:20+08:00</updated><id>http://localhost:4000/2019/12/18/ISO-7064</id><content type="html" xml:base="http://localhost:4000/2019/12/18/ISO-7064.html">&lt;p&gt;&lt;img src=&quot;../assets/blogImg/201912181143.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在生活中，有一些游戏账号的实名认证和申请
或者某些网站的注册会用到身份证号。&lt;/p&gt;

&lt;p&gt;当输入错误的身份证号时会提示出错
给人的感觉是他们真的能识别身份证信息一样。
当然，除了一些政府、银行、证券、保险等行业接入的是NCIIC（全国公民身份证号码查询服务中心）
其他的大多数都是根据最后一位校验位来判断该身份证号码是否有效。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;目前国内最权威的渠道肯定是全国公民身份证号码查询服务中心，简称NCIIC，
也就是很多实名认证服务商所声称采用的公安部接口。
实际上由于公安网跟外网是隔绝的，所以公安部的接口绝对是不会直接对外的提供的。
NCIIC是隶属于公安部的一个事业单位，可以直连国家人口基础信息库，
其数据权威性主要表现在：数据更新准确，公民的出生、死亡、 姓名变更等信息都会第一时间更新，
可以满足政府、金融等机构的对数据质量的高要求。
所以NCIIC的授权范围，也主要集中在政府、银行、证券、保险等行业。&lt;/p&gt;

&lt;h4 id=&quot;结构和形式&quot;&gt;结构和形式&lt;/h4&gt;

&lt;p&gt;1．号码的结构
　　公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。
2．地址码
　　表示编码对象常住户口所在县（县级市、旗、区）的行政区划代码，按GB/T2260的规定执行。
3．出生日期码
　　表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。
4．顺序码
　　表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。
5．校验码
　　根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。&lt;/p&gt;

&lt;p&gt;地址码：
华北地区：北京市|110000，天津市|120000，河北省|130000，山西省|140000，内蒙古自治区|150000
东北地区： 辽宁省|210000，吉林省|220000，黑龙江省|230000
华东地区： 上海市|310000，江苏省|320000，浙江省|330000，安徽省|340000，福建省|350000，江西省|360000，山东省|370000
华中地区： 河南省|410000，湖北省|420000，湖南省|430000
华南地区：广东省|440000，广西壮族自治区|450000，海南省|460000
西南地区：重庆市|500000，四川省|510000，贵州省|520000，云南省|530000，西藏自治区|540000
西北地区： 陕西省|610000，甘肃省|620000，青海省|630000，宁夏回族自治区|640000，新疆维吾尔自治区|650000
特别地区：台湾地区(886)|830000，香港特别行政区（852)|810000，澳门特别行政区（853)|820000&lt;/p&gt;

&lt;p&gt;中国大陆居民身份证号码中的地址码的数字编码规则为：
第一、二位表示省（自治区、直辖市、特别行政区）。
第一位数字是以前的大区制代码。第二位是大区所在省市编码。全国共分为6个大区：华北局（1）、东北局（2）、华东局（3）、中南局（4）、西南局（5）和西北局（6）
第三、四位表示市（地级市、自治州、盟及国家直辖市所属市辖区和县的汇总码）。其中，01-20，51-70表示省直辖市；21-50表示地区（自治州、盟）。
第五、六位表示县（市辖区、县级市、旗）。01-18表示市辖区或地区（自治州、盟）辖县级市；21-80表示县（旗）；81-99表示省直辖县级市。&lt;/p&gt;

&lt;p&gt;其中第十七位奇数分给男性，偶数分给女性。
作为尾号的校验码，是由号码编制单位按统一的公式计算出来的，如果某人的尾号是0-9，都不会出现X，但如果尾号是10，那么就得用X来代替&lt;/p&gt;

&lt;h4 id=&quot;iso-70641983mod-11-2计算方法&quot;&gt;ISO 7064:1983.MOD 11-2计算方法&lt;/h4&gt;

&lt;p&gt;1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。
2、将这17位数字和系数相乘的结果相加。
3、用加出来和除以11，看余数是多少？
4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。(即余数0对应1，余数1对应0，余数2对应X…)
5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是2，身份证的最后一位号码就是罗马数字X。
例如：某男性的身份证号码为【53010219200508011X】， 我们看看这个身份证是不是符合计算规则的身份证。
首先我们得出前17位的乘积和【&lt;code class=&quot;highlighter-rouge&quot;&gt;(5*7)+(3*9)+(0*10)+(1*5)+(0*8)+(2*4)+(1*2)+(9*1)+(2*6)+(0*3)+(0*7)+(5*9)+(0*10)+(8*5)+(0*8)+(1*4)+(1*2)&lt;/code&gt;】是189，然后用189除以11得出的结果是189÷11=17余下2，187÷11=17，还剩下2不能被除尽，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的检验码是X。所以，可以判定这是一个正确的身份证号码。&lt;/p&gt;

&lt;p&gt;JavaScript代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//验证方法
function verifyCode(id){
 if(id.length !=18 )
  return false;
 /*1、从第一位到第十七位的系数分别为：
   7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2
   将这17位数字和系数相乘的结果相加。 */
 var arr = [7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2];
 var sum = 0;
 for(var i=0; i&amp;lt;arr.length; i++){
  sum += parseInt(id.charAt(i)) * arr[i];
 }
 //2、用加出来和除以11，看余数，
 var c = sum%11;
 //3、分别对应的最后一位身份证的号码为：1－0－X－9－8－7－6－5－4－3－2
 var ch = [‘1‘, ‘0‘, ‘X‘, ‘9‘, ‘8‘, ‘7‘, ‘6‘, ‘5‘, ‘4‘, ‘3‘, ‘2‘];
 var code = ch[c];
 var last = id.charAt(17);
 last = last==‘x‘ ? ‘X‘: last;
 return last == code;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var id = &quot;34052419800101001X&quot;;
 console.log(verifyCode(id));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>true</name></author><category term="算法" /><category term="身份证校验" /><summary type="html"></summary></entry><entry><title type="html">【翻译】 第六篇 Atomic Design with React</title><link href="http://localhost:4000/2019/11/30/Atomic-Design-with-React.html" rel="alternate" type="text/html" title="【翻译】 第六篇 Atomic Design with React" /><published>2019-11-30T23:59:24+08:00</published><updated>2019-11-30T23:59:24+08:00</updated><id>http://localhost:4000/2019/11/30/Atomic-Design-with-React</id><content type="html" xml:base="http://localhost:4000/2019/11/30/Atomic-Design-with-React.html">&lt;center&gt;&lt;h1&gt; React 的原子设计&lt;/h1&gt;&lt;/center&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;本文来自阅读极客时间专栏《左耳听风》89&lt;/td&gt;
        &lt;td&gt;程序员练级攻略：UI/UX设计 文章中的推荐阅读&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;原文链接：https://codeburst.io/atomic-design-with-react-e7aea8152957&lt;/li&gt;
  &lt;li&gt;作者：Danilo Woznica&lt;/li&gt;
  &lt;li&gt;2018年1月9日&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/translate/201912042105.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How the Atomic Design methodology allowed me to create a great design system from scratch and made me a better developer, with principles of componentization, hierarchies and reuses of code.&lt;/p&gt;

&lt;p&gt;原子设计方法论是如何让我从零开始创建一个伟大的设计系统，并使我成为一个更好的开发人员，具有组件化、层次结构和代码重用的原则。
&lt;!--more--&gt;
I have recently had the opportunity to work on a new product from scratch made in React and PWA with the well-crafted and componentized UI at Cheesecake. However, when we discussed with the whole team the best way to approach the development, we ended up having the same old problems that have happened in most past projects, such as:&lt;/p&gt;

&lt;p&gt;我最近有机会在一个新的产品从零开始的反应和 PWA 与精心制作和组件化的 UI 在芝士蛋糕。 然而，当我们与整个团队讨论处理开发的最佳方法时，我们最终遇到了与过去大多数项目中发生的相同的老问题，例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Lack of Styleguide of components; 缺乏构件的样式指南;&lt;/li&gt;
  &lt;li&gt;Lack of precision in estimating development time; 估计开发时间不精确;&lt;/li&gt;
  &lt;li&gt;Great amount of setup time for developers; 为开发人员提供大量的安装时间;&lt;/li&gt;
  &lt;li&gt;Inconsistency between components and view; 组件与视图不一致;&lt;/li&gt;
  &lt;li&gt;Repeated code; 重复代码;&lt;/li&gt;
  &lt;li&gt;Side effects; 副作用;&lt;/li&gt;
  &lt;li&gt;Very specific components to each pages; 每个页面都有非常具体的组件;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ve started to build the CSS architecture using the ITCSS methodology that organizes the style files on stacks from generics styles to the specifics ones, which helps you to scale large projects easily. But along with ITCSS, we were using CSS Modules to scope the components, so we noticed that component stack was getting huge and even the generic styles were being componentized and reused within other one.&lt;/p&gt;

&lt;p&gt;我们已经开始使用 ITCSS 方法来构建 CSS 架构，这种方法将样式文件从泛型样式组织到具体样式，这有助于您轻松地扩展大型项目。 但是与 ITCSS 一起，我们使用 CSS 模块来调整组件的范围，所以我们注意到组件堆栈变得越来越庞大，甚至通用样式也被组件化并在其他组件中重用。&lt;/p&gt;

&lt;p&gt;That was the moment in which we paused to rethink our architecture and how we could set the components in a more distributed and organized way. Then we found a methodology called Atomic Design that creates multiples stacks of components, with different hierarchies of complexity and dependence.&lt;/p&gt;

&lt;p&gt;在那一刻，我们停下来重新思考我们的体系结构，以及我们如何将组件设置成更加分布和有组织的方式。 然后我们发现了一种叫做原子设计的方法，它创建了多个组件堆栈，具有不同的复杂性和依赖性层次结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301609.png&quot; alt=&quot;原子设计层次结构&quot; title=&quot;原子设计层次结构&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-is-atomic-design&quot;&gt;What is Atomic Design?&lt;/h2&gt;

&lt;h2 id=&quot;什么是原子设计&quot;&gt;什么是原子设计？&lt;/h2&gt;

&lt;p&gt;Popularly known within the design world, Atomic Design helps to build consistent, solid and reusable design systems. Plus, in the world of React, Vue and frameworks that stimulate the componentization, Atomic Design is used unconsciously; but when used in the right way, it becomes a powerful ally for developers.&lt;/p&gt;

&lt;p&gt;原子设计在设计界广为人知，它帮助构建一致、可靠和可重用的设计系统。 另外，在 React、 Vue 和促进组件化的框架的世界中，原子设计是无意识地使用的; 但是当使用得当时，它成为了开发人员的强大盟友。&lt;/p&gt;

&lt;p&gt;The name Atomic Design comes from the idea of separating the components in atoms, molecules, organisms, templates and pages, like in the image above. But what are the responsibilities of each separated part?&lt;/p&gt;

&lt;p&gt;“原子设计”这个名字来源于这样一个想法，即将原子、分子、有机体、模板和页面中的成分分离开来，如上图所示。 但是，每个独立部分的责任是什么？&lt;/p&gt;

&lt;h3 id=&quot;atoms&quot;&gt;Atoms&lt;/h3&gt;
&lt;h3 id=&quot;原子&quot;&gt;原子&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301613.png&quot; alt=&quot;原子组件示例&quot; title=&quot;原子组件示例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Atoms are the smallest possible components, such as buttons, titles, inputs or event color pallets, animations, and fonts. They can be applied on any context, globally or within other components and templates, besides having many states, such as this example of button: disabled, hover, different sizes, etc.&lt;/p&gt;

&lt;p&gt;原子是最小的可能组件，例如按钮、标题、输入或事件颜色托盘、动画和字体。 它们可以应用于任何上下文，全局或其他组件和模板，除了有许多状态，如这个按钮的例子: 禁用，悬停，不同大小等。&lt;/p&gt;

&lt;h3 id=&quot;molecules&quot;&gt;Molecules&lt;/h3&gt;
&lt;h3 id=&quot;分子&quot;&gt;分子&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301615.png&quot; alt=&quot;分子组成的例子&quot; title=&quot;分子组成的例子&quot; /&gt;&lt;/p&gt;

&lt;p&gt;They are the composition of one or more components of atoms. Here we begin to compose complex components and reuse some of those components. Molecules can have their own properties and create functionalities by using atoms, which don’t have any function or action by themselves.
它们是由一个或多个原子组成的。 在这里，我们开始组合复杂的组件并重用其中的一些组件。 分子可以有自己的属性，通过原子创造功能，而原子本身没有任何功能或作用。&lt;/p&gt;

&lt;h3 id=&quot;organisms&quot;&gt;Organisms&lt;/h3&gt;
&lt;h3 id=&quot;有机体&quot;&gt;有机体&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301635.png&quot; alt=&quot;生物成分的例子&quot; title=&quot;生物成分的例子&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Organisms are the combination of molecules that work together or even with atoms that compose more elaborate interfaces. At this level, the components begin to have the final shape, but they are still ensured to be independent, portable and reusable enough to be reusable in any content.&lt;/p&gt;

&lt;p&gt;有机体是分子的组合，这些分子相互作用，甚至与原子组成更复杂的界面。 在这个级别上，组件开始具有最终的形状，但仍然保证它们是独立的、可移植的和可重用的，足以在任何内容中重用。&lt;/p&gt;

&lt;h3 id=&quot;templates&quot;&gt;Templates&lt;/h3&gt;
&lt;h3 id=&quot;模板&quot;&gt;模板&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301636.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this state we stop composing components and begin to set their context. Moreover, the templates create relationships between the organisms and others components through positions, placements and patterns of the pages but it doesn’t have any style, color or component rendered. That’s why it looks like a wireframe.
在这种状态下，我们停止组合组件并开始设置它们的上下文。 此外，模板通过页面的位置、位置和模式在有机体和其他组件之间创建关系，但它没有任何风格、颜色或组件渲染。 这就是为什么它看起来像线框图。&lt;/p&gt;

&lt;h3 id=&quot;pages&quot;&gt;Pages&lt;/h3&gt;
&lt;h3 id=&quot;页数&quot;&gt;页数&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301638.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pages are the navigate parts of the application and it’s where the components are distributed in one specific template. The components get real content and they’re connected with the whole application. At this stage, we can test the efficiency of the design system to analyse if all the components are independent enough or if we need to split them in smaller parts.&lt;/p&gt;

&lt;p&gt;页面是应用程序的导航部分，它是组件在一个特定模板中分布的位置。 这些组件获得真正的内容，并与整个应用程序相连接。 在这个阶段，我们可以测试设计系统的效率，以分析是否所有的组件都足够独立，或者是否需要将它们拆分成更小的部分。&lt;/p&gt;

&lt;h3 id=&quot;react--atomic-design&quot;&gt;React + Atomic Design&lt;/h3&gt;
&lt;h3 id=&quot;react--原子设计&quot;&gt;React + 原子设计&lt;/h3&gt;

&lt;p&gt;When we started to use Atomic Design within React we had to adjust some rules of the methodology to ensure that components were reused as much as possible, that they were stateless, without styles of positions and very specific margins so to avoid any side effects in the pages of application.
当我们开始在 React 中使用 Atomic Design 时，我们不得不调整方法的一些规则，以确保组件被尽可能多地重用，确保它们是无状态的，没有位置样式和非常具体的边距，以避免应用程序页面中的任何副作用。&lt;/p&gt;

&lt;p&gt;So with each new component we asked ourselves: “Are these components generic enough to avoid specificity and/or repeated code in whatever context they are used?”
因此，对于每一个新组件，我们都要问自己: “这些组件是否足够通用，以避免在任何情况下使用特殊性和 / 或重复代码? ”&lt;/p&gt;

&lt;p&gt;So we were able to write a few rules:
所以我们可以写一些规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The Atomic Design should have a file of variables and it must be imported by each component;
1.原子设计应具有一个变量文件，并且必须由每个组件导入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The atoms should be written without margins and positions;
2.原子应该写在没有边缘和位置的地方；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only the molecules and organisms can set the positions of atoms, but these stacks can’t have any styles of margins and positions;
3.只有分子和有机体可以设置原子的位置，但这些堆栈不能有任何类型的边距和位置;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Templates have only one function: to set the grid of pages but never positions of specific components;
4.模板只有一个功能: 设置页面的网格，但不设置特定组件的位置;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pages render the components with a template defined and it’s here that the Atomic Design will be connected to the rest of the application;
5.页面使用定义的模板呈现组件，在这里原子设计将连接到应用程序的其余部分;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;lets-code&quot;&gt;Let’s code&lt;/h3&gt;
&lt;h3 id=&quot;让我们来编码&quot;&gt;让我们来编码&lt;/h3&gt;

&lt;p&gt;What I will show here is everything in a boilerplate on GitHub, which you can test and then start your projects using Atomic Design, so let’s do it:
这里我要展示的是 GitHub 上的样板文件，你可以测试它，然后使用 Atomic Design 开始你的项目，所以让我们开始吧:&lt;/p&gt;

&lt;p&gt;To build a UI LIbrary we used an awesome tool called Storybook, which is a great ally to the Atomic Design in React (you can use it for the React Native and Vue too), it allows to render the components and list all states/variations of one.
为了构建 UI LIbrary，我们使用了一个非常棒的工具 Storybook，它是原子设计在反应(你可以使用它为反应原生和 Vue 也)的一个很好的盟友，它允许渲染组件和列出一个的所有状态 / 变化。&lt;/p&gt;

&lt;p&gt;With the Storybook installed the folder structure will look like this:
安装了 Storybook 后，文件夹结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201912042026.png&quot; alt=&quot;Structure folder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that inside of the button component there is a file called ‘index.js’ which is the component itself, the ‘styles.css’ is the style that will be imported by CSS Modules (here we’ve used the BEM CSS inside the structure; I recommend reading the article ‘CSS Architecture with ReactJS’) and the ‘stories.js’ is the file that will import the component into the Storybook, which looks like this:
注意，在按钮组件的内部有一个叫做‘ index.js’的文件，它是组件本身，‘ styles.CSS’是由 CSS 模块导入的样式(这里我们在结构中使用了 BEM CSS; 我推荐阅读文章‘ CSS Architecture with ReactJS’) ，而‘ stories.js’是将组件导入 Storybook 的文件，它看起来像这样:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201912042029.png&quot; alt=&quot;Storybook’s file&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each ‘add ()’ function is a variation of the component and it is the best approach to describe each state individually rather than a single function, so it becomes easier to highlight and control each one of them. So if you describe all the component variations , the Storybook should look like this:
每个 add ()函数都是组件的一个变体，它是描述每个状态的最佳方法，而不是单个函数，因此更容易突出和控制每个状态。 因此，如果你描述所有的组件变化，故事书应该是这样的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201912042030.png&quot; alt=&quot;Storybook interface&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And the coolest part of the Storybook is that you can add some ‘addons’, such as the Storybook Info, which does awesome things like: story source, props types, defaults values and which values are required or not.
故事书最酷的部分是你可以添加一些插件，比如故事书信息，它可以做一些很棒的事情，比如: 故事来源，道具类型，默认值以及哪些值是必需的或者不是。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201912042031.png&quot; alt=&quot;Storybook table&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;At the end of project, we reached the initial goals and we believe we left a good legacy, a structure which ensures that the project can grow and that other developers can understand the architecture quickly. Maybe we initially spent some extra time writing stories and etc, but the more the project grows, the more the benefits make clear why we should use such architecture.
在项目结束时，我们达到了最初的目标，并且我们相信我们留下了一个很好的遗产—- 一个确保项目可以成长并且其他开发人员可以快速理解架构的结构。 也许我们最初花费了一些额外的时间来写故事等等，但是随着项目的增长，好处越来越明显，为什么我们应该使用这样的架构。&lt;/p&gt;

&lt;p&gt;However we could see that this architecture probably doesn’t work for every project because it depends on several factors. The main one is that the design needs to be thought in the same way as the development: in an atomic way. But the integration between design and development is a point that every project wants to reach, so it becomes a very positive point for Atomic Design.
然而，我们可以看到，这种架构可能不适用于每个项目，因为它取决于几个因素。 主要的一点是，设计需要以与开发相同的方式来考虑: 以原子的方式。 但是设计和开发之间的集成是每个项目都想要达到的，所以这对于原子设计来说是一个非常积极的点。&lt;/p&gt;</content><author><name>true</name></author><category term="翻译" /><category term="React" /><category term="设计方法" /><summary type="html">React 的原子设计</summary></entry><entry><title type="html">【翻译】 第五篇 The Evolution of UI/UX Designers Into Product Designers</title><link href="http://localhost:4000/2019/11/30/The-Evolution-of-UI-UX-Designers-Into-Product-Designers.html" rel="alternate" type="text/html" title="【翻译】 第五篇 The Evolution of UI/UX Designers Into Product Designers" /><published>2019-11-30T18:48:41+08:00</published><updated>2019-11-30T18:48:41+08:00</updated><id>http://localhost:4000/2019/11/30/The-Evolution-of-UI-UX-Designers-Into-Product-Designers</id><content type="html" xml:base="http://localhost:4000/2019/11/30/The-Evolution-of-UI-UX-Designers-Into-Product-Designers.html">&lt;center&gt;&lt;h1&gt; 从 ui / ux 设计师到产品设计师的演变&lt;/h1&gt;&lt;/center&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;本文来自阅读极客时间专栏《左耳听风》89&lt;/td&gt;
        &lt;td&gt;程序员练级攻略：UI/UX设计 文章中的推荐阅读&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;原文链接：https://medium.com/thinking-design/the-evolution-of-ui-ux-designers-into-product-designers-623e4e7eaab3&lt;/li&gt;
  &lt;li&gt;作者：Adobe Creative Cloud&lt;/li&gt;
  &lt;li&gt;2017年1月18日&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/translate/201911301134.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What is a product? Until recently, the term was only used in relation to something material and often found in a retail store, but nowadays it is coming to mean digital products as well. Apps are modern products.&lt;/p&gt;

&lt;p&gt;什么是产品？ 直到最近，这个词还只是用来指物质的东西，通常在零售店里才能找到，但是现在它也开始指数字产品了。 应用程序是现代产品。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;When it comes to building great products, design is the most important “feature.” We’ve moved into the stage where product design dominates — it’s what sets companies apart and gives a real edge over competitors.&lt;/p&gt;

&lt;p&gt;当谈到建立伟大的产品，设计是最重要的“特征。” 我们已经进入了产品设计占主导地位的阶段ーー这是公司与众不同的地方，也是相对于竞争对手的真正优势所在。&lt;/p&gt;

&lt;p&gt;The design industry has evolved quite a lot in the last few years and today there are a number of different responsibilities encompassed by the umbrella term designer: UX Designers, UI Designers, and Product Designers. “What is the difference between these job roles?” is a fairly common question in design industry. Let’s attempt to distill what each of these titles really mean, and look at why the evolution of UI/UX Designers into Product Designers is a logical development in the era of modern technology.&lt;/p&gt;

&lt;p&gt;在过去的几年里，设计行业已经发生了很大的变化，如今，设计师这个总称涵盖了许多不同的职责: 用户体验设计师、用户界面设计师和产品设计师。 “这些工作角色之间的区别是什么? ” 在设计行业是一个相当普遍的问题。 让我们尝试提炼出每一个标题的真正含义，并且看看为什么 ui / ux 设计师进化成产品设计师是现代技术时代的一个合乎逻辑的发展。&lt;/p&gt;

&lt;h2 id=&quot;ux-ui-product-who-does-what&quot;&gt;UX, UI, Product: Who Does What?&lt;/h2&gt;

&lt;h2 id=&quot;用户体验用户界面产品-谁做了什么&quot;&gt;用户体验，用户界面，产品: 谁做了什么？&lt;/h2&gt;

&lt;p&gt;All of these roles have one thing in common — they all design how a user interacts with a product. But these people all perform slightly different functions to reach the same goal.&lt;/p&gt;

&lt;p&gt;所有这些角色都有一个共同点: 他们都设计用户如何与产品交互。 但是这些人为了达到同一个目标，所执行的功能略有不同。&lt;/p&gt;

&lt;h3 id=&quot;ux-designer-user-experience-designer&quot;&gt;UX Designer (User Experience Designer)&lt;/h3&gt;

&lt;h3 id=&quot;用户体验设计师&quot;&gt;用户体验设计师&lt;/h3&gt;

&lt;p&gt;UX designers are primarily concerned with how the product feels. The goal is make the user’s interaction as efficient and simple as possible. UX designers look at design from the mindspace of a user and squash potential problems by:&lt;/p&gt;

&lt;p&gt;用户体验设计师主要关心的是产品的感觉。 我们的目标是让用户的交互尽可能的高效和简单。 用户体验设计师从用户的思维空间来看待设计，通过以下方式来消除潜在的问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Writing various product user scenarios and building patterns of interaction.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编写各种产品用户场景和构建交互模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Resorting to various kinds of testing and watching what users do (e.g. usability-lab studies, eye-tracking, A/B testing, email surveys, etc).&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过各种测试和观察用户的行为(例如: 可用性实验室研究、眼球追踪、 a / b 测试、电子邮件调查等)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Prototyping an interface and creating the products logic via wireframes.&lt;/li&gt;
  &lt;li&gt;原型化界面并通过线框图创建产品逻辑&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ui-designer-user-interface-designer&quot;&gt;UI Designer (User Interface Designer)&lt;/h3&gt;
&lt;h3 id=&quot;ui-设计师用户界面设计师&quot;&gt;Ui 设计师(用户界面设计师)&lt;/h3&gt;

&lt;p&gt;UI designers, on the other hand are the people who are primarily concerned how the product looks. They responsible for how we see the product in its final version. They are in charge of designing each screen or page with which a user interacts and ensuring that the user interface visually communicates the logic that a UX designer has offered (for example, a UI designer creating a data dashboard can front load the most important content at the top). UI designers are also responsible for creating a style guide and unified visual language that is applied across the product.&lt;/p&gt;

&lt;p&gt;另一方面，UI 设计师主要关心的是产品的外观。 他们负责我们如何看待产品的最终版本。 他们负责设计用户交互的每个屏幕或页面，并确保用户界面可视化地传达用户体验设计师提供的逻辑(例如，创建数据指示板的用户界面设计师可以在顶部前端加载最重要的内容)。 Ui 设计师还负责创建一个样式指南和统一的视觉语言，应用于整个产品。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301238.png&quot; alt=&quot;Ui 设计师找到了突出显示那些应该吸引用户注意力的元素的最佳方式&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;product-designer&quot;&gt;Product Designer&lt;/h3&gt;
&lt;h3 id=&quot;产品设计师&quot;&gt;产品设计师&lt;/h3&gt;

&lt;p&gt;Product Designer is a sum-up term used to describe a designer who is generally involved in the creation of the look and feel of a whole product. Many product designers consider themselves to be designers who design experiences. This means that a product designer is the one who gives real insight to UX and UI designers when it comes to how certain features should work, or how a certain UI control should look.&lt;/p&gt;

&lt;p&gt;产品设计师是一个总结术语，用来描述一个设计师，他通常参与创造整个产品的外观和感觉。 许多产品设计师认为自己是有设计经验的设计师。 这意味着产品设计师是那个在特定功能应该如何工作，或者特定 UI 控件应该如何外观方面给用户体验和用户界面设计师提供真正见解的人。&lt;/p&gt;

&lt;p&gt;Companies use the term ‘Product Designer’ differently; the most general definition is a person who’s a champion of a user’s needs. As Justin Edmund said, “A product designer oversees product vision from a high level (how does this feature make sense for where we want to be in 6 months) to a low execution level (how does styling this button this way impact how the user flows through this function).”&lt;/p&gt;

&lt;p&gt;公司使用“产品设计师”这个术语的方式不同; 最普遍的定义是一个能够满足用户需求的人。 正如 Justin Edmund 所说，“产品设计师监督产品远景，从高层次(这个功能对我们6个月后的目标有什么意义)到低层次的执行(这样设计这个按钮如何影响用户通过这个功能的流程)。”&lt;/p&gt;

&lt;h2 id=&quot;drivers-of-design-evolution&quot;&gt;Drivers of Design Evolution&lt;/h2&gt;
&lt;h2 id=&quot;设计进化的驱动力&quot;&gt;设计进化的驱动力&lt;/h2&gt;

&lt;p&gt;Design and its component practices are like any other craft: you can always develop a deeper familiarity with the minutiae and master your skills by taking more active role in whole design process. There’s a general positive trend of designers taking on a larger scope of responsibilities within the product development process, and here are some drivers for this trend:&lt;/p&gt;

&lt;p&gt;设计及其组件实践就像其他工艺一样: 你总是可以通过在整个设计过程中扮演更积极的角色，对细节有更深入的了解，并掌握自己的技能。 设计师在产品开发过程中承担更大范围的责任，这是一个普遍的积极趋势，以下是这一趋势的一些驱动因素:&lt;/p&gt;

&lt;h3 id=&quot;design-thinking&quot;&gt;Design Thinking&lt;/h3&gt;

&lt;h3 id=&quot;设计思维&quot;&gt;设计思维&lt;/h3&gt;

&lt;p&gt;Design thinking has become a popular approach for designing a product. The best design reflects the product’s goals. Good designers have always applied design thinking to product design, whether physical or digital, because it’s focussed on end-to-end product development, not just the “design phase” part.&lt;/p&gt;

&lt;p&gt;设计思维已经成为一种流行的产品设计方法。 最好的设计反映了产品的目标。 优秀的设计师总是将设计思维应用到产品设计中，无论是物理设计还是数字设计，因为他们关注的是端到端的产品开发，而不仅仅是“设计阶段”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301253.png&quot; alt=&quot;设计思维是一个以人为中心的创造过程，为用户构建有意义和有效的解决方案。&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When thinking in products, designers should understand business objectives and be able to answer the following questions first:&lt;/p&gt;

&lt;p&gt;在思考产品时，设计师应该理解商业目标，并能够首先回答以下问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;What problem do we solve? 我们要解决什么问题？&lt;/li&gt;
  &lt;li&gt;Who has these problems? 谁有这些问题？&lt;/li&gt;
  &lt;li&gt;Why are we doing this? 我们为什么要这么做？&lt;/li&gt;
  &lt;li&gt;How are we doing this? 我们要怎么做？&lt;/li&gt;
  &lt;li&gt;What do we want to achieve? 我们想要实现什么？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Answering these questions helps designers understand the user experience of a product as a whole; not purely as interaction (feel) or visual (look) design part. Only after that it makes sense to move to the actual state offinding a design solution which includes following 6 phases:&lt;/p&gt;

&lt;p&gt;回答这些问题可以帮助设计师理解整个产品的用户体验，而不仅仅是交互(感觉)或视觉(外观)设计部分。 只有在这之后，才有意义转移到实际状态，提出一个包括以下6个阶段的设计方案:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Empathize: Conduct research to develop a deeper understanding of your users.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;感同身受: 进行研究，深入了解你的用户&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Define: Combine your research and observe where your users’ problem exist. In pinpointing your users’ needs, begin to highlight opportunities for innovation.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;定义: 结合你的研究，观察用户存在问题的地方。 在精确定位用户的需求时，开始强调创新的机会&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Ideate: Generate a range of potential solutions by giving yourself and your team total freedom.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;想法: 通过给你自己和你的团队完全的自由来产生一系列可能的解决方案&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Prototype: Build a prototype (or series of prototypes) to test your solution. Creating a prototype lets designer see if they’re on the right track, and often sparks different ideas that wouldn’t come in other cases.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prototype: 构建一个原型(或一系列原型)来测试您的解决方案。 创建一个原型让设计师看看他们是否在正确的轨道上，并经常会激发不同的想法，不会出现在其他情况下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Test: Return to your users for feedback. Ask yourself ‘Does this solution meet users’ needs?’&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试: 返回给你的用户以获得反馈。 问问自己这个解决方案是否满足用户的需求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Implement” Put the vision into effect. Ensure that your solution is materialized and works for your users. This step is crucial for the entire process.&lt;/li&gt;
  &lt;li&gt;实施”把愿景付诸实施。 确保您的解决方案是具体化的，并且对用户有效。 这一步对整个过程至关重要&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301259.png&quot; alt=&quot;设计思维框架&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;collaborative-work&quot;&gt;Collaborative Work&lt;/h3&gt;
&lt;h3 id=&quot;协同工作&quot;&gt;协同工作&lt;/h3&gt;

&lt;p&gt;More and more companies try to unify designers and developers into the development process. This new way of product development has two major benefits:&lt;/p&gt;

&lt;p&gt;越来越多的公司试图将设计师和开发人员统一到开发过程中。 这种新的产品开发方式有两个主要好处:&lt;/p&gt;

&lt;p&gt;Working together in a collaborative environment creates a situation where team members are encouraged to think wildly. Also embracing the critique of a whole team is the best way to refine something that, if designed in isolation, is at risk of becoming impossible to use.&lt;/p&gt;

&lt;p&gt;在一个协作的环境中共同工作创造了一种鼓励团队成员广泛思考的情况。 接受整个团队的批评也是改进某些东西的最好方法，如果单独设计，就有变得不可能使用的风险&lt;/p&gt;

&lt;p&gt;Methodologies such as Agile and Lean leads to designers and other team members working more cross-functionally with larger scopes of responsibility. 方法论，例如敏捷及倾斜导致设计师和其他团队成员在更大的职责范围内跨职能地工作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301305.png&quot; alt=&quot;一个统一的过程促进更好的工作&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;continuous-improvement-iterative-design&quot;&gt;Continuous Improvement (Iterative Design)&lt;/h3&gt;

&lt;h3 id=&quot;持续改进迭代设计&quot;&gt;持续改进(迭代设计)&lt;/h3&gt;

&lt;p&gt;Unlike more traditional forms of design, design process for digital products isn’t a one-time thing and designers should never assume to get everything right on the first go. Implementation often reveals gaps in the design: undocumented conditions or bad assumptions about product usage, which hard to predict without shipping the product.&lt;/p&gt;

&lt;p&gt;与传统的设计形式不同，数字产品的设计过程不是一次性的，设计师永远不应该假设一开始就把每件事都做对。 实现往往会揭示设计中的差距: 没有记录的条件或关于产品使用的错误假设，如果没有运输产品，就很难预测。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301308.png&quot; alt=&quot;如何构建产品&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To design a successful product you need to adopt a process of continuous improvement. Iterative design follows the idea that design should be done in repeated cycles: it’s a process of constantly refining and improving the product based on both qualitative and quantitative feedback data from your users. This is a great opportunity for designers to see a bigger picture, improve their work based on user feedback and make the product inherently more valuable to the user.&lt;/p&gt;

&lt;p&gt;为了设计一个成功的产品，你需要采用一个持续改进的过程。 迭代设计遵循的思想是设计应该在重复的循环中进行: 它是一个不断地改进和提高产品的过程，这个过程基于来自用户的定性和定量的反馈数据。 对于设计师来说，这是一个很好的机会，他们可以看到更大的图景，根据用户的反馈改进他们的工作，使产品对用户来说更有价值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/201911301309.png&quot; alt=&quot;产品设计是一个依赖于设计思维的迭代过程。&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;Product design represents the next enlargement of design scope, from just user experience design towards an even broader state of design for an entire product.&lt;/p&gt;

&lt;p&gt;产品设计代表了下一次设计范围的扩大，从单纯的用户体验设计到更广泛的整个产品设计状态。&lt;/p&gt;

&lt;p&gt;The best products are built by people who understand the whole product, not just their silo. In order to make such products, UI/UX Designers should look to evolve into Product Designers who are able to generate and process a additional information to get the best result.&lt;/p&gt;

&lt;p&gt;最好的产品是由了解整个产品的人创造的，而不仅仅是他们自己的筒仓。 为了制造这样的产品，ui / ux 设计师应该考虑发展成为能够生成和处理附加信息以获得最佳结果的产品设计师。&lt;/p&gt;</content><author><name>true</name></author><category term="翻译" /><category term="Adobe" /><category term="产品设计的演化过程" /><summary type="html">从 ui / ux 设计师到产品设计师的演变</summary></entry><entry><title type="html">如何在 Windows 上安装 Django并创建应用</title><link href="http://localhost:4000/2019/10/18/How-to-install-Django-and-create-application-on-Windows.html" rel="alternate" type="text/html" title="如何在 Windows 上安装 Django并创建应用" /><published>2019-10-18T02:03:31+08:00</published><updated>2019-10-18T02:03:31+08:00</updated><id>http://localhost:4000/2019/10/18/How-to-install-Django-and-create-application-on-Windows</id><content type="html" xml:base="http://localhost:4000/2019/10/18/How-to-install-Django-and-create-application-on-Windows.html">&lt;p&gt;&lt;img src=&quot;../assets/blogImg/201910251755.jfif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文将指导您如何在 Windows 上安装 Python 3.7.4和 Django。 
它还提供了关于安装 virtualenv 和 virtualenvwrapper 的说明。
这使得在 Python 项目中工作更加容易。&lt;br /&gt;
这是为 Django 项目工作的用户提供的初学者指南，并不反映在为 Django 本身开发补丁时应该如何安装 Django。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本指南中的步骤已经在 Windows 7、8和10中测试过了。 在其他版本中，步骤类似。 你将需要熟悉使用命令提示符。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h2 id=&quot;安装-python&quot;&gt;安装 Python&lt;/h2&gt;

&lt;p&gt;Django 是一个 Python web 框架，因此需要在机器上安装 Python。 在撰写本文时，使用的是Python 3.7.4版本。&lt;/p&gt;

&lt;p&gt;要在你的机器上安装 Python，请访问 google https://Python.org/downloads/ 。 这个网站应该为你提供一个最新版本的 Python 下载按钮。 下载可执行安装程序并运行它。 选中“向 PATH 添加 Python 3.5”旁边的复选框，然后单击“立即安装”。&lt;/p&gt;

&lt;p&gt;安装完成后，打开命令提示符并检查 Python 版本是否与您通过执行以下命令安装的版本相匹配:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;关于pip&quot;&gt;关于pip&lt;/h2&gt;

&lt;p&gt;Pip 是 Python 的一个包管理。 它进行安装和卸载 Python 包(比如 Django!) 很简单。 对于安装的其余部分，我们将使用 pip 从命令行安装 Python 包。&lt;/p&gt;

&lt;p&gt;要在您的计算机上安装 pip，请转到安装 https://pip.pypa.io/en/latest/Installing/ ，并按照 get-pip.py 说明进行安装。&lt;/p&gt;

&lt;p&gt;如果您正在使用 Python 22.7.9或 Python 33.4，或者您正在 virtualenv 或 pyvenv 创建的虚拟环境中工作，那么 pip 已经安装。 只需确保升级 pip 即可。&lt;/p&gt;

&lt;h2 id=&quot;安装virtualenv-及virtualenvwrapper&quot;&gt;安装virtualenv 及virtualenvwrapper&lt;/h2&gt;

&lt;p&gt;Virtualenv 和 virtualenvwrapper 为您创建的每个 Django 项目提供一个专用的环境。 虽然不是强制性的，但这被认为是最佳实践，并且在将来准备部署项目时将为您节省时间。 简单地输入:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install virtualenvwrapper-win
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后为你的项目创建一个虚拟环境:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkvirtualenv myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;虚拟环境将被自动激活，您将在命令提示符旁边看到“(myproject)”来指定该虚拟环境。 如果你启动一个新的命令提示符，你需要使用以下命令再次激活环境:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;workon myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装-django&quot;&gt;安装 Django&lt;/h2&gt;

&lt;p&gt;可以在虚拟环境中使用 pip 轻松地安装 Django。&lt;/p&gt;

&lt;p&gt;在命令提示符中，确保虚拟环境处于活动状态，并执行以下命令:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install django
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这将下载并安装最新的 Django 版本。&lt;/p&gt;

&lt;p&gt;安装完成后，您可以通过在命令提示符中执行 Django-admin – version 来验证您的 Django 安装。&lt;/p&gt;

&lt;h2 id=&quot;编写你的第一个-django-应用程序&quot;&gt;编写你的第一个 Django 应用程序&lt;/h2&gt;

&lt;h4 id=&quot;创建一个项目&quot;&gt;创建一个项目&lt;/h4&gt;

&lt;p&gt;如果这是您第一次使用 Django，那么您必须处理一些初始设置。 也就是说，您需要自动生成一些代码来建立 Django 项目—— Django 实例的设置集合，包括数据库配置、特定于 Django 的选项和特定于应用程序的设置。&lt;/p&gt;

&lt;p&gt;从命令行中，cd 进入你想存储代码的目录，然后运行以下命令:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...\&amp;gt; django-admin startproject mysite
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这将在你的工作目录文件夹中创建一个 mysite 目录。 如果不起作用，请参阅运行 django-admin 的问题。&lt;/p&gt;

&lt;p&gt;让我们来看看 startproject 创建了什么:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;manage.py：命令行实用程序，允许您以各种方式与这个 django 项目交互。&lt;/li&gt;
  &lt;li&gt;mysite/&lt;strong&gt;init&lt;/strong&gt;.py: 一个空文件，它告诉 Python 这个目录应该被视为一个 Python 包。&lt;/li&gt;
  &lt;li&gt;mysite/settings.py: 此 Djangoproject 的设置 / 配置。&lt;/li&gt;
  &lt;li&gt;mysite/urls.py: 这个 Django 项目的 URL 声明; 您的 Django 驱动站点的“目录”。&lt;/li&gt;
  &lt;li&gt;mysite/wsgi.py:为您的项目提供与 wsgi 兼容的 web 服务器的入口点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;开发服务器&quot;&gt;开发服务器&lt;/h2&gt;

&lt;p&gt;让我们验证一下您的 Django 项目是否正常工作。 如果你还没有进入外部 mysite 目录，可以运行以下命令:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...\&amp;gt; py manage.py runserver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;您将在命令行上看到以下输出:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Performing system checks...

System check identified no issues (0 silenced).

You have unapplied migrations; your app may not work properly until they are applied.
Run 'python manage.py migrate' to apply them.

October 16, 2019 - 15:50:53
Django version 2.2, using settings 'mysite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;您已经启动了 Django 开发服务器，这是一个纯粹用 Python 编写的轻量级 Web 服务器。 我们已经在 Django 中包含了这一点，这样您就可以快速开发，而无需配置生产服务器(比如 Apache) ，直到您准备好投入生产。&lt;/p&gt;

&lt;p&gt;现在是注意的好时机: 不要在任何类似于生产环境的环境中使用此服务器。 它只能在开发过程中使用。 (我们的业务是制作 Web 框架，而不是 Web 服务器。)&lt;/p&gt;

&lt;p&gt;现在服务器已经运行，可以使用 Web 浏览器访问 google http://127.0.0.1:8000/ 。 你会看到一个“恭喜! ” 佩奇，火箭正在起飞。 成功了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/blogImg/201910171811.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;改变端口&quot;&gt;①改变端口&lt;/h4&gt;
&lt;p&gt;默认情况下，runserver 命令在内部 IP 端口8000启动开发服务器。
如果要更改服务器端口，请将其作为命令行参数传递。 例如，这个命令在端口8080上启动服务器:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...\&amp;gt; py manage.py runserver 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果您想更改服务器的 IP，请将它与端口一起传递。 例如，要侦听所有可用的公共 ip (如果你正在运行 Vagrant 或者想在网络上的其他计算机上炫耀你的工作，这是很有用的) ，使用:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...\&amp;gt; py manage.py runserver 0:8000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;0是0.0.0.0的捷径。 开发服务器的完整文档可以在 runserver 参考中找到。&lt;/p&gt;

&lt;h4 id=&quot;运行服务器的自动重新加载&quot;&gt;②运行服务器的自动重新加载&lt;/h4&gt;

&lt;p&gt;开发服务器根据需要为每个请求自动重新加载 Python 代码。 您不需要重新启动服务器，代码更改即可生效。 但是，像添加文件样的
操作不会触发重新启动，因此在这些情况下必须重新启动服务器。&lt;/p&gt;

&lt;h2 id=&quot;创建投票应用程序&quot;&gt;创建投票应用程序&lt;/h2&gt;

&lt;p&gt;现在您的环境(一个“项目”)已经设置好了，您就可以开始工作了。&lt;/p&gt;

&lt;p&gt;您在 Django 中编写的每个应用程序都由遵循某种约定的 Python 包组成。 自带了一个工具，可以自动生成应用程序的基本目录结构，所以你可以专注于编写代码而不是创建目录。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;## 项目 vs 应用程序
项目和应用程序有什么区别？ 应用程序是一个 Web 应用程序，它可以做一些事情，比如 Weblog 系统、公共记录数据库或者一个简单的投票应用程序。 项目是针对特定网站的配置和应用程序的集合。 一个项目可以包含多个应用程序。 一个应用程序可以在多个项目中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你的应用程序可以在你的 Python 路径上的任何地方运行。 在本教程中，我们将在 manage.py 文件旁边创建我们的投票应用程序，这样它就可以作为自己的顶级模块导入，而不是 mysite 的子模块。&lt;/p&gt;

&lt;p&gt;要创建你的应用程序，确保你和 manage.py 在同一个目录下，然后输入以下命令:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...\&amp;gt; py manage.py startapp polls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这将创建一个目录民意调查，如下所示:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个目录结构将存放轮询应用程序。&lt;/p&gt;

&lt;h2 id=&quot;写下你的第一个观点&quot;&gt;写下你的第一个观点&lt;/h2&gt;

&lt;p&gt;让我们编写第一个视图。 打开文件 polls / views.py 并在其中放入以下 Python 代码:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;polls/views.py
```
from django.http import HttpResponse&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;def index(request):
    return HttpResponse(“Hello, world. You’re at the polls index.”)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是 Django 中最简单的视图。 要调用这个视图，我们需要将它映射到一个 URL ——为此我们需要一个 URLconf。

要在 polls 目录中创建 URLconf，请创建一个名为 urls.py 的文件。 你的应用程序目录现在应该是这样的:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;polls/
    &lt;strong&gt;init&lt;/strong&gt;.py
    admin.py
    apps.py
    migrations/
        &lt;strong&gt;init&lt;/strong&gt;.py
    models.py
    tests.py
    urls.py
    views.py&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在 polls / urls.py 文件中包含以下代码:
&amp;gt; polls/urls.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;from django.urls import path&lt;/p&gt;

&lt;p&gt;from . import views&lt;/p&gt;

&lt;p&gt;urlpatterns = [
    path(‘’, views.index, name=’index’),
]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;下一步是将根 URLconf 指向 polls.url 模块。 在 mysite / urls.py 中，为 django.urls.include 添加一个导入，并在 urlpatterns 列表中插入一个 include () ，这样就可以:

&amp;gt; mysite/urls.py

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;from django.contrib import admin
from django.urls import include, path&lt;/p&gt;

&lt;p&gt;urlpatterns = [
    path(‘polls/’, include(‘polls.urls’)),
    path(‘admin/’, admin.site.urls),
]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;函数允许引用其他 URLconfs。 无论 Django 遇到什么 include () ，它都会删除与该点匹配的 URL 的任何部分，并将剩余的字符串发送到包含的 URLconf 进行进一步处理。

Include ()背后的思想是为了便于插入和播放 url。 因为民意调查是在它们自己的 URLconf (polls / urls.py)中，所以它们可以放在“ / polls / ” ，或者“ / fun polls / ” ，或者“ / content / polls / ” ，或者任何其他路径根目录下，这个应用程序仍然可以工作。


&amp;gt; #### 何时使用 include ()
&amp;gt; 当您包含其他 URL 模式时，您应该始终使用 include ()。 Url 是唯一的例外。

您现在已经将索引视图连接到 URLconf。 确认它正在使用以下命令:

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;…&amp;gt; py manage.py runserver
```
在你的浏览器中进入 http://localhost:8000/polls/ ，你会看到文本“Hello, world. You’re at the polls index.” ，您在索引视图中定义的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;页面没有找到&quot;&gt;页面没有找到？&lt;/h4&gt;
  &lt;p&gt;如果你在这里得到一个错误页面，检查你要去的是 http://localhost:8000/polls/ ，而不是 http://localhost:8000/ 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Path ()函数传递了四个参数，其中两个是必需的: route 和 view，两个是可选的: kwargs 和 name。 在这一点上，我们有必要回顾一下这些争论的目的。&lt;/p&gt;

&lt;h3 id=&quot;path-argument-route&quot;&gt;path() argument: route&lt;/h3&gt;

&lt;p&gt;Route 是一个包含 URL 模式的字符串。 当处理一个请求时，Django 从 urlpatterns 中的第一个模式开始，沿着列表一路向下，将请求的 URL 与每个模式进行比较，直到找到匹配的模式。&lt;/p&gt;

&lt;p&gt;模式不搜索 GET 和 POST 参数或域名。 例如，在对 myapp / https://www.example.com/myapp/ 的请求中，URLconf 将查找 myapp / 。 在 https://www.example.com/myapp/?page=3的请求中，URLconf 也会查找 myapp / 。&lt;/p&gt;

&lt;h3 id=&quot;path-argument-view&quot;&gt;path() argument: view&lt;/h3&gt;

&lt;p&gt;当 Django 找到一个匹配模式时，它调用指定的视图函数，其中以 HttpRequest 对象作为第一个参数，并将 route 中的任何“捕获”值作为关键字参数。 我们稍后会给出一个例子。&lt;/p&gt;

&lt;h3 id=&quot;path-argument-kwargs&quot;&gt;path() argument: kwargs&lt;/h3&gt;

&lt;p&gt;可以在字典中将任意关键字参数传递给目标视图。 我们不打算在本教程中使用 Django 的这个特性。&lt;/p&gt;

&lt;h3 id=&quot;path-argument-name&quot;&gt;path() argument: name&lt;/h3&gt;

&lt;p&gt;命名 URL 可以让您明确地从 Django 中的其他地方引用它，尤其是从模板中。 这个功能强大的特性允许您对项目的 URL 模式进行全局更改，同时只触及单个文件。&lt;/p&gt;

&lt;p&gt;当您熟悉了基本的请求和响应流后，请阅读本教程的第2部分以开始使用数据库。&lt;/p&gt;</content><author><name>true</name></author><category term="python" /><category term="Django" /><summary type="html"></summary></entry><entry><title type="html">三阶魔方教程</title><link href="http://localhost:4000/2019/09/16/Third-level-cube-tutorial.html" rel="alternate" type="text/html" title="三阶魔方教程" /><published>2019-09-16T05:19:28+08:00</published><updated>2019-09-16T05:19:28+08:00</updated><id>http://localhost:4000/2019/09/16/Third-level-cube-tutorial</id><content type="html" xml:base="http://localhost:4000/2019/09/16/Third-level-cube-tutorial.html">&lt;p&gt;&lt;img src=&quot;../assets/blogImg/201909152135.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;

&lt;p&gt;魔方 ，英文名为Rubik’s Cube，又叫鲁比克方块，台湾地区称之为魔术方块，香港地区称之为扭计骰，最早是由匈牙利布达佩斯建筑学院厄尔诺·鲁比克（又称作厄尔诺·卢比克）教授于1974年发明的。魔方与中国人发明的“华容道”，法国人发明的“独立钻石”一起被称为世界三大智力运动。魔方竞速是一项手部极限运动。&lt;/p&gt;

&lt;p&gt;三阶发明以后，许多其他种类型的魔方纷纷出现靠，如二阶（2&lt;em&gt;2&lt;/em&gt;2）、四阶、五阶、六阶…..至今已达到十三阶。还有许多节点的异形魔方，如五魔方、镜面。金字塔、斜转、SQ1、不等阶、捆绑、连体、空心、齿轮、魔中魔、超级转角、智慧之轮、时间机器等等……&lt;/p&gt;

&lt;!--more--&gt;
&lt;h2 id=&quot;二魔方的比赛相关&quot;&gt;二、魔方的比赛相关&lt;/h2&gt;

&lt;p&gt;世界魔方协会（英文 ：Word Cube Association，简称WCA）是魔方官方的国际性赛事组织，成立于2003年，只有通过世界魔方协会的比赛才能记载入世界纪录。WCA现有的比赛记录：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;~&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;单次&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;平均&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;二阶&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.49&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.51&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;三阶&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6.45&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;四阶&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;21.54&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;26.06&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;五阶&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;44.83&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;53.08&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;六阶&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1:33.55&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1:44.88&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;七阶&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2:20.66&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2:25.06&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;三阶盲拧&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;21.05&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;24.72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;三阶单手&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6.88&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;10.7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;魔表&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.76&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5.72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;脚拧&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20.57&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;28.16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;五魔方&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;35.94&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42.89&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;金字塔&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.32&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.41&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SQ1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6.84&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9.90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;斜转&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.10&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.76&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;最小步&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;19步&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;24.33步&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;三魔方的其他玩法&quot;&gt;三、魔方的其他玩法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;速拧–有15秒观察时间，用最短的时间复原一个魔方，快者为胜。&lt;/li&gt;
  &lt;li&gt;盲拧–将魔方记忆下来，不得做笔记，接着戴上眼罩并且由裁判用纸板挡住视线，复原魔方。记忆魔方的时间也算入最终成绩。&lt;/li&gt;
  &lt;li&gt;多盲–参赛者在比赛项目开始前必须说明将还原的魔方数目，每个魔方有十分钟的记忆时间，总时间限制为一个小时，最终成绩分数成功个数减去失败个数，
相同分数时用时最短者胜。&lt;/li&gt;
  &lt;li&gt;单拧–也称三单，即用单手复原魔方，复原阶段开始后一旦接触到魔方，则不能用其他部位包括另一只手或物品接触魔方。&lt;/li&gt;
  &lt;li&gt;脚拧–用脚复原魔方，一般为坐在合适高度的椅子上复原。&lt;/li&gt;
  &lt;li&gt;最小步–可自备最多三个魔方，白纸和笔若干，在1小时内把解法写在纸上，最小步者为胜。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四魔方界名人&quot;&gt;四、魔方界名人&lt;/h2&gt;

&lt;p&gt;菲神：Feliks Zemdegs，1995年12月20日出生在澳大利亚墨尔本。魔方界的天才，目前已打破78项魔方世界记录，并且多数是打破自己的记录。
庄海燕：网名瓦西里（老瓦），盲拧传奇人物。
张砷镓：国内首个WCA赛中单次SUB10的魔友，魔方系列文章非常有水准，特别是《十字天书》对许多CROSS提速有非常大的帮助。
中岛悠：曾打破多项世界纪录，“中岛非标”可以说是速拧必修课。
江淦源：前中国世界纪录保持者，其编写的GANCFOP和其创立的江淦源GAN品牌三阶魔方均受到广大魔友的好评。&lt;/p&gt;

&lt;h2 id=&quot;五魔方常用术语&quot;&gt;五、魔方常用术语&lt;/h2&gt;

&lt;p&gt;N阶：阶数一般指魔方主体部分两个相邻旋转面共有的块数，如三阶魔方每个边有三个小块，四阶每边有四个小块。
复原：指魔方从非原始状态到原始状态的过程。
容错：魔方没转到位，仍然可以转动其它层的一个能力。
SUB：Subtraction，在魔方圈内一般指在xx以下、以内。
AVG：Average，指平均成绩。
DNF：Did not finish，指放弃此次成绩。
DNS：Did not start ，指复原开始前弃权。
PB: Personal Best.指个人魔方最快记录。
UWR：Unofficial World Record，指非官方统计世界纪录。
WR：World Record，指世界纪录；（世界WR全国NR亚洲AsR欧洲ER北美洲NAR南美SAR大洋OcR 非洲AfR）
WCA：World Cube Association，指世界魔方协会。
FSC：  Finger Short Cut的缩写。指由一组旋转动作组成的、在公式中经常出现的顺手手法（如 R U R’ U’）。
CZZ：有两种含义①拆再装法 ②Cross+ZBF2L+ZBLL法。
BLD：Blindfold Cubing，指盲拧。
PSC：Prepared Solve Challenge，指同一条打乱公式，自行研究解法并录制视频上传，以还原时间最短者为胜。
LBL：Layer By Layer的简称。指层先法（七步法、基础法）。
CFOP：Fridrich Method 的简称，三阶速拧复原法，流程为Cross、F2L、OLL、PLL，取每一步骤的首字母作为简称。
Cross：十字。指还原底层的4个棱块。
F2L：Frist Two Layers的缩写。指CFOP法复制前两层的方法。
OLL：Orientation of Last Layer 的缩写。指最后一层朝向。
PLL：Permutation of Last Layer 的缩写。指最后一层换位。
跳P：指魔方幸运地直接复原，跳过了PLL步骤。跳0同理。&lt;/p&gt;

&lt;h2 id=&quot;六魔方花样公式&quot;&gt;六、魔方花样公式&lt;/h2&gt;

&lt;p&gt;六面回字： U’  D  F’  B  L  R’  U’  D
四色回字： B2  L  R  B  L2  B  F  D  U’  B  F  R2  F’  L  R
对称棋盘： L2  R2  F2  B2  U2   D2
循环棋盘： D2  F2  U’  B2  F2  L2  R2  D  R’  B  F  D’  U  L  R  D2  U2  F’  U2 
六面十字： B2  F’  L2  R2  D2  B2  F2  L2  R2  U2  F’
四面十字： U2  R  B  D  B  F’  L’  U’  B  F’  L  F  L’  R  D  U2  F’  R’  U2
六面五色： U  B2  L2  B  F’  U  F’  D2  L  D2  F  D  R2  F2  R’  B’  U’  R’
六面六色： D2  U2  L2  B  R2  D’  L2  R2  D2  B2  F2  U’ R2  B’  R2
六面彩条： F2  U2  F2  B2  U2  F  B
六面三条：（U2  L2）3  (U2  R2)3  U  D  L2  R2
六面凹字： F2  L’  R  B2  U2  L  R’  D2
六面凹字： U  D  L2  F2  U  D’  B2  R2  D2
六面凹：    F2  R  F2  R’    U2  F2  L  U2  B2  U2  F’  U2  R  D’  B2  D  F’  D2  R  F
六面工字： D2  M  L’  F2  B2  M  D2
六面Q字：  D  F2  U’  B  F’  L  R’  D  L2  U’  B  R2  B’  U  L2  U’
六面J字：   D2  L2  D  R2  U  B2  U2  B R’  B’  D  B2  R’  F  R2  F’  U  R’
六面L字：   L  R  U  D  F’  B’  L  R
六面E字：   F2  R2  F2  U’  R’  B2  F  L  R’  U  L’  R U B  U2 F2  D’  U’
六面U字：  D’  U  B  D’  L’ R  F  D’  U  L
六面T字：  U2  F2  R2  D  U’  L2  B2 D  U     或者    B2  D2  L  R’  D2  B2  L  R
CCTV字：  B2  R2  D2  U2  F2  L  R’  U2  L’  R’
大小魔方： U2L2F2  U’B2D  RF’RF’RF’  D’B2U’&lt;/p&gt;

&lt;h2 id=&quot;七公式说明&quot;&gt;七、公式说明&lt;/h2&gt;

&lt;p&gt;R  =  right 右面        F = front 前面        U =  up  上面
L  =  left  左面          B = back 后面        D =  down 下面&lt;/p&gt;

&lt;p&gt;图：&lt;/p&gt;

&lt;p&gt;公式记忆技巧：
大写表示一层，小写表示两层，带撇表示逆时针，不带撇表示顺时针。  M表示中间层（Middle），xyz表示魔方整体转动。&lt;/p&gt;

&lt;p&gt;在四节或更高阶魔方里，由于多了很多层，所以另做以下定义：&lt;/p&gt;

&lt;p&gt;M3R 表示从R层往左数的第三层单独转动，M2R缩写成MR。
T3R  表示从R层往左数的三个层同时转动。T2R缩写TR。
同理M4L,T3L 
注意：顺逆时针，是基于正式着对应面的时候判断的。&lt;/p&gt;

&lt;h2 id=&quot;八三阶魔方教程&quot;&gt;八、三阶魔方教程&lt;/h2&gt;

&lt;h4 id=&quot;本教程以白色为底建议大家也先按教程来方便学习&quot;&gt;①本教程以白色为底，建议大家也先按教程来，方便学习。&lt;/h4&gt;
&lt;p&gt;1.1 在顶层组成小花
黄色中心块朝上，找到四个白色的棱块（白红，白橙，白绿，白蓝），如果在中层则可直接将其转到顶面。
如果他在底层或者顶层，需要先转到中层再处理。
注意：如果已有白棱在顶层，应先转动顶层避开，在归位。&lt;/p&gt;

&lt;p&gt;如果已有白棱在顶层，应先转动顶层避开，在归位：&lt;/p&gt;

&lt;p&gt;1.2  复原白色十字
转动顶层，使白色的棱块侧面颜色和中块颜色一致，将此层转动180度到底面。四个白色棱块注意按此方法归位到底层，第一步完成。&lt;/p&gt;

&lt;h4 id=&quot;对好侧面t字&quot;&gt;②对好侧面T字&lt;/h4&gt;
&lt;p&gt;第二步目标：此步目标是复位四个带有白色的角块（白红蓝、白红绿、白橙蓝、白橙绿），令第一层复原，在侧面可以看到一个倒着的“T”字。&lt;/p&gt;

&lt;p&gt;2.1 复原顶层白色角块&lt;/p&gt;

&lt;p&gt;公式1： R U R’ U’&lt;/p&gt;

&lt;p&gt;2.2 复原底层白色角块
当顶层找不到白色角块后，在进行这一步：&lt;/p&gt;

&lt;p&gt;用上述方法即可复原四个白色角块，至此底层完成进行下一步。&lt;/p&gt;

&lt;h4 id=&quot;复原中层棱块&quot;&gt;③复原中层棱块&lt;/h4&gt;
&lt;p&gt;此步目标是复原四个没有黄色面的棱块（红蓝，红绿，橙蓝，橙绿）。&lt;/p&gt;

&lt;p&gt;3.1 复原在顶层的中层棱块
转动顶层（U）使要复原的块停在侧面颜色和中心块颜色相同的位置，对照以下两种情况做对应处理（目标位置要对着我们）&lt;/p&gt;

&lt;p&gt;公式2： U R U’ R’ U’ F’ U F&lt;/p&gt;

&lt;p&gt;公式3： U’ F’ U F U R U’ R’&lt;/p&gt;

&lt;p&gt;大家可以发现这两个情况是镜像的，公式也是镜像的。这两条简单公式可以观察规律，结合自己的理解来记忆。&lt;/p&gt;

&lt;p&gt;3.2 复原在中层错误的棱块&lt;/p&gt;

&lt;p&gt;当第三层无合适的棱块时，在第二层找到未复原的棱块，接着转一次公式2可将其移动到顶层，再按对应情况处理。至此第三步完成。&lt;/p&gt;

&lt;p&gt;前两层都完成后，恭喜你可以进行下一步了。&lt;/p&gt;

&lt;h4 id=&quot;对顶层的黄色十字&quot;&gt;④对顶层的黄色十字&lt;/h4&gt;

&lt;p&gt;顶层有以下四种情况，对照图中的所示的朝向，转公式4处理即可。&lt;/p&gt;

&lt;p&gt;公式4： F  R  U  R’  U’  F’&lt;/p&gt;

&lt;p&gt;当你的魔方完成上图所示后，可进行下一步。&lt;/p&gt;

&lt;h4 id=&quot;复原顶层&quot;&gt;⑤复原顶层&lt;/h4&gt;
&lt;p&gt;重复一下步骤最多三次即可复原顶层。&lt;/p&gt;

&lt;p&gt;1、转动顶层将魔方和某个俯视图朝向保持一致（俯视图的黄条表示侧面的黄色面，黄条也要对应上。）
2、转公式5
	公式5：R  U  R’  U  R  U2  R’
为了方便记忆观察顶面的四个角块，以上情况可总结成三种：
A: 有0面黄色面时（十字），把侧面两个黄色面朝向左边。
B：有两面黄色面时（坦克、双鱼），把侧面黄色面放在前面左侧。
C：有1面黄色面时（小鱼），把鱼头朝向左下。&lt;/p&gt;

&lt;h4 id=&quot;对凹字&quot;&gt;⑥对凹字&lt;/h4&gt;
&lt;p&gt;一直转动U层知道前面左上和右上角颜色相同，转公式6即可对好凹字。如果找不到相同的，则先直接转一次公式6在观察。&lt;/p&gt;

&lt;p&gt;公式6： R’  U  L’  U2  R  U’  R’  U2  L  R&lt;/p&gt;

&lt;h4 id=&quot;复原顶棱&quot;&gt;⑦复原顶棱&lt;/h4&gt;
&lt;p&gt;如果剩下的四个棱块都未归位，则直接转一次公式7即可归位其中的一个，如果剩下三个棱块未复原，则把已复原好的棱块放在背面，转公式7最多两次即可
复原魔方。&lt;/p&gt;

&lt;p&gt;公式7：R2  U  R  U  R’  U’  R’  U’  R’  U  R’&lt;/p&gt;</content><author><name>true</name></author><category term="魔方" /><category term="三阶魔方" /><summary type="html">一、简介</summary></entry><entry><title type="html">JavaScript 面试题收集 –持续更新</title><link href="http://localhost:4000/2019/08/31/javascript-Interview-questions.html" rel="alternate" type="text/html" title="JavaScript 面试题收集    --持续更新" /><published>2019-08-31T05:52:57+08:00</published><updated>2019-08-31T05:52:57+08:00</updated><id>http://localhost:4000/2019/08/31/javascript-Interview-questions</id><content type="html" xml:base="http://localhost:4000/2019/08/31/javascript-Interview-questions.html">&lt;p&gt;&lt;img src=&quot;../assets/blogImg/201908302202.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;送你-43-道-javascript-面试题&quot;&gt;送你 43 道 JavaScript 面试题&lt;/h2&gt;

&lt;p&gt;原文链接：https://juejin.im/post/5d0644976fb9a07ed064b0ca&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下面代码的输出是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sayHi() {
  console.log(name);
  console.log(age);
  var name = &quot;Lydia&quot;;
  let age = 21;
}

sayHi();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A: Lydia 和 undefined
B: Lydia 和 ReferenceError
C: ReferenceError 和 21
D: undefined 和 ReferenceError&lt;/p&gt;

&lt;p&gt;答案: D
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;在函数中，我们首先使用var关键字声明了name变量。 这意味着变量在创建阶段会被提升（JavaScript会在创建变量创建阶段为其分配内存空间），默认值为undefined，直到我们实际执行到使用该变量的行。 我们还没有为name变量赋值，所以它仍然保持undefined的值。
使用let关键字（和const）声明的变量也会存在变量提升，但与var不同，初始化没有被提升。 在我们声明（初始化）它们之前，它们是不可访问的。 这被称为“暂时死区”。 当我们在声明变量之前尝试访问变量时，JavaScript会抛出一个ReferenceError。
译者注：
关于let的是否存在变量提升，我们何以用下面的例子来验证：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name = 'ConardLi'
{
  console.log(name) // Uncaught ReferenceError: name is not defined
  let name = 'code秘密花园'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let变量如果不存在变量提升，console.log(name)就会输出ConardLi，结果却抛出了ReferenceError，那么这很好的说明了，let也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或赋值前不允许访问。
变量的赋值可以分为三个阶段：&lt;/p&gt;

&lt;p&gt;创建变量，在内存中开辟空间
初始化变量，将变量初始化为undefined
真正赋值&lt;/p&gt;

&lt;p&gt;关于let、var和function：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;let 的「创建」过程被提升了，但是初始化没有提升。&lt;/li&gt;
  &lt;li&gt;var 的「创建」和「初始化」都被提升了。&lt;/li&gt;
  &lt;li&gt;function 的「创建」「初始化」和「赋值」都被提升了。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;下面代码的输出是什么?&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (var i = 0; i &amp;lt; 3; i++) {
  setTimeout(() =&amp;gt; console.log(i), 1);
}

for (let i = 0; i &amp;lt; 3; i++) {
  setTimeout(() =&amp;gt; console.log(i), 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A: 0 1 2 and 0 1 2
B: 0 1 2 and 3 3 3
C: 3 3 3 and 0 1 2&lt;/p&gt;

&lt;p&gt;答案: C
由于JavaScript中的事件执行机制，setTimeout函数真正被执行时，循环已经走完。 由于第一个循环中的变量i是使用var关键字声明的，因此该值是全局的。 在循环期间，我们每次使用一元运算符++都会将i的值增加1。 因此在第一个例子中，当调用setTimeout函数时，i已经被赋值为3。
在第二个循环中，使用let关键字声明变量i：使用let（和const）关键字声明的变量是具有块作用域的（块是{}之间的任何东西）。 在每次迭代期间，i将被创建为一个新值，并且每个值都会存在于循环内的块级作用域。&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;下面代码的输出是什么?&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () =&amp;gt; 2 * Math.PI * this.radius
};

shape.diameter();
shape.perimeter();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A: 20 and 62.83185307179586
B: 20 and NaN
C: 20 and 63
D: NaN and 63&lt;/p&gt;

&lt;p&gt;答案: B
请注意，diameter是普通函数，而perimeter是箭头函数。
对于箭头函数，this关键字指向是它所在上下文（定义时的位置）的环境，与普通函数不同！ 这意味着当我们调用perimeter时，它不是指向shape对象，而是指其定义时的环境（window）。没有值radius属性，返回undefined。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;28-道-javascript-面试题看看能错几道&quot;&gt;28 道 JavaScript 面试题，看看能错几道？&lt;/h2&gt;

&lt;p&gt;原文链接：https://mp.weixin.qq.com/s/o260IGR5FxvN-P8Kgtz1uA&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下面代码输出什么?&lt;/li&gt;
&lt;/ol&gt;</content><author><name>true</name></author><summary type="html"></summary></entry><entry><title type="html">【翻译】(第四篇)18 designers predict UI/UX trends for 2018</title><link href="http://localhost:4000/2019/08/10/18-designers-predict-UI-UX-trends-for-2018.html" rel="alternate" type="text/html" title="【翻译】(第四篇)18 designers predict UI/UX trends for 2018" /><published>2019-08-10T23:25:22+08:00</published><updated>2019-08-10T23:25:22+08:00</updated><id>http://localhost:4000/2019/08/10/18-designers-predict-UI-UX-trends-for-2018</id><content type="html" xml:base="http://localhost:4000/2019/08/10/18-designers-predict-UI-UX-trends-for-2018.html">&lt;center&gt;&lt;h1&gt; 18位设计师预测2018年用户界面/用户体验趋势&lt;/h1&gt;&lt;/center&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;本文来自阅读极客时间专栏《左耳听风》89&lt;/td&gt;
        &lt;td&gt;程序员练级攻略：UI/UX设计 文章中的推荐阅读&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;** 原文链接：https://www.figma.com/blog/eighteen-designers-predict-ui-ux-trends-for-2018/ **&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;作者：Valerie Veteto&lt;/li&gt;
  &lt;li&gt;2017年12月15日&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/translate/UX_Design_Trends_Cover.jfif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Designers are always looking toward the future — in our “build and ship it now” industry we’re programmed to iterate ad finitum. In the end, a designer’s obsession always circles back to one simple question: How can we improve the user’s experience?
&lt;!--more--&gt;
设计师总是在展望未来-在我们的“现在制造和推广”行业中，我们被编程为迭代定义。最后，设计师的痴迷总是绕回到一个简单的问题上：我们如何才能改善用户体验？&lt;/p&gt;

&lt;p&gt;With that in mind, Figma asked 18 designers what UI/UX trends they predict for 2018. December, with its flurry of holiday parties, cheery OOO auto-replies and introspective weather patterns, provided the perfect opportunity to pause and survey the landscape.
考虑到这一点，Figma询问了18位设计师，他们预测2018年的用户界面/用户体验趋势。12月，伴随着节日派对的风潮，欢快的OOO自动回复和反省的天气模式，提供了一个完美的机会来暂停和调查景观。&lt;/p&gt;

&lt;p&gt;Designers were culled from a few different sources: those who attended last month’s Figma sponsored design systems dinner, speakers at this year’s Clarity Conference and friends of the Figma family. You’ll read through opinions from designers who work anywhere from Facebook to Google to Airbnb. We even crowdsourced Twitter, receiving 61 thoughtful responses that were much appreciated.
设计师们被从几个不同的来源中挑选出来: 那些参加了上个月 Figma 赞助的设计系统晚宴的人，今年 Clarity 大会的演讲者，以及 Figma 家族的朋友。 你可以阅读从 Facebook 到 Google 再到 Airbnb 的设计师们的意见。 我们甚至把 Twitter 众包出去，收到了61条深思熟虑的回复，这些回复都非常令人感激。&lt;/p&gt;

&lt;p&gt;Like a collective hive brain, many designers touched on similar topics, from accessibility and ethical accountability, to collaborative design.
像一个集体蜂巢大脑一样，许多设计师也谈到了类似的话题，从可及性和道德责任，到协同设计。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/blue_guy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-accessibility-will-be-first-ego-second&quot;&gt;1. Accessibility will be first, ego second&lt;/h1&gt;
&lt;h1 id=&quot;1-可达性第一自我第二&quot;&gt;1. 可达性第一，自我第二&lt;/h1&gt;

&lt;p&gt;“I really hope 2018 is the year designers commit to designing with accessibility in mind. We need to stop using ultra light grays for essential elements, we need to stop animating every single pixel just because it looks nice, and we need to stop making it harder on people to understand the content of a page only because we want to prove ourselves as designers.”
“我真的希望2018年是设计师们致力于设计时考虑到无障碍性的一年。 我们需要停止使用超轻灰色作为基本元素，我们需要停止仅仅因为每个像素看起来漂亮就对其进行动画处理，我们需要停止仅仅因为我们想证明自己是设计师就让人们更难理解页面的内容。”&lt;/p&gt;

&lt;p&gt;Hubert Florin, Product Designer at Slack
休伯特 · 弗洛林，Slack 的产品设计师&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/red_woman.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-collaboration-in-design-will-echo-engineering&quot;&gt;2. Collaboration in design will echo engineering&lt;/h1&gt;
&lt;h1 id=&quot;2-设计方面的合作将与工程学相呼应&quot;&gt;2. 设计方面的合作将与工程学相呼应&lt;/h1&gt;

&lt;p&gt;“Whether or not designers code, I think that design teams will start to collaborate a lot more like engineering teams. That might include design reviews akin to code reviews, design tools that function like code linters, or an uptick in open source design patterns. What would software be like if all open source engineering projects had design equivalents driving industry standards in user experience or information design?”
“无论设计师是否编写代码，我认为设计团队将开始更像工程团队一样合作。 这可能包括类似于代码审查的设计审查，功能类似于代码短片的设计工具，或者开源设计模式的提升。 如果所有的开源工程项目在用户体验或信息设计方面都有驱动行业标准的设计等价物，那么软件会是什么样子呢？”&lt;/p&gt;

&lt;p&gt;Jules Forrest, Senior Product Designer at Credit Karma 
朱尔斯 · 福里斯特，Credit Karma 高级产品设计师&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/tim_belonax.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-designers-will-focus-on-ethics&quot;&gt;3. Designers will focus on ethics&lt;/h1&gt;
&lt;h1 id=&quot;3-设计师会关注道德&quot;&gt;3. 设计师会关注道德&lt;/h1&gt;

&lt;p&gt;“My hope is UX/UI designers become more aware of their influence in 2018 and take into greater account the ethical ramifications of their design choices for the people that use their products.”
“我希望用户体验 / 用户界面设计师在2018年能够更多地意识到他们的影响力，更多地考虑他们的设计选择对使用他们产品的人的道德影响。”&lt;/p&gt;

&lt;p&gt;Tim Belonax, Lead Designer at Pinterest. 
Pinterest的首席设计师 Tim Belonax&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/johan_ronsse.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-designers-will-lean-too-heavily-on-the-industry-standard&quot;&gt;4. Designers will lean too heavily on the industry standard&lt;/h1&gt;
&lt;h1 id=&quot;4-设计师过于依赖行业标准&quot;&gt;4. 设计师过于依赖行业标准&lt;/h1&gt;

&lt;p&gt;“Unfortunately I predict increased reliance on prescribed design systems (I.e. Material, Fluent) without questioning them.”
“不幸的是，我预测会越来越依赖规定的设计系统(即 Material，Fluent) ，而不去质疑它们。”&lt;/p&gt;

&lt;p&gt;Johan Ronsse, UI/UX Designer and Partner at Mono Design
Johan Ronsse，ui / ux 设计师，Mono Design 合伙人&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/diana_mounter.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;5-with-great-efficiency-comes-great-responsibility&quot;&gt;5. With great efficiency comes great responsibility&lt;/h1&gt;
&lt;h1 id=&quot;5-效率越高责任越大&quot;&gt;5. 效率越高，责任越大&lt;/h1&gt;

&lt;p&gt;“In 2018, I think we’ll see design and development tools continue to converge, with more centralized tools helping to design and build systems to work with whatever technology or platform you need. We’ll see CSS grid, custom variables, and frameworks like Vue and React bring new possibilities and greater efficiencies to design implementation — I hope this creates the space to spend more time designing responsibly, and building more inclusive experiences.”
“在2018年，我认为我们将看到设计和开发工具继续融合，更多的集中化工具帮助设计和构建系统，以满足您所需的任何技术或平台。 我们将看到 CSS 网格、自定义变量，以及 Vue 和 React 等框架为设计实现带来了新的可能性和更高的效率ーー我希望这能创造空间，让我们花更多时间进行负责任的设计，构建更具包容性的体验。”&lt;/p&gt;

&lt;p&gt;Diana Mounter, Design Systems Manager at GitHub
戴安娜 · 蒙特，GitHub 设计系统经理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/matthew_morek.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6-were-going-to-ignore-the-one-trend-we-all-need&quot;&gt;6. We’re going to ignore the one trend we all need&lt;/h1&gt;
&lt;h1 id=&quot;6-我们将忽略我们都需要的一个趋势&quot;&gt;6. 我们将忽略我们都需要的一个趋势&lt;/h1&gt;

&lt;p&gt;“The one trend we all need, but is not likely to take the industry by storm or even make headlines, is design for accessibility and inclusive design. There’s a lot of work in that area and barely anyone wants to touch it. #accessibility”
“我们都需要的一个趋势是无障碍设计和包容性设计，但这个趋势不太可能席卷整个行业，甚至不会成为头条新闻。 那个领域有很多工作，几乎没有人愿意去碰它。 # 无障碍”&lt;/p&gt;

&lt;p&gt;Matthew Morek, UI/UX Design Consultant
Matthew Morek，ui / ux 设计顾问&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/michelle_morrison.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;7-design-will-be-a-major-player-in-social-change&quot;&gt;7. Design will be a major player in social change&lt;/h1&gt;
&lt;h1 id=&quot;7-设计将在社会变革中扮演重要角色&quot;&gt;7. 设计将在社会变革中扮演重要角色&lt;/h1&gt;

&lt;p&gt;“Design that matters most is design that solves real human problems. Forward looking, I see design playing a major role in how we tackle the big, nasty issues in society. Design will become more political, more accessible, and a toolset that affects real change.”
“最重要的设计是解决真正的人类问题的设计。 展望未来，我认为设计在我们如何处理社会中的重大问题上扮演着重要的角色。 设计将变得更加政治化，更加易于理解，并成为影响真正变化的工具集。”&lt;/p&gt;

&lt;p&gt;Michelle Morrison, Design Program Manager at Facebook
米歇尔 · 莫里森，Facebook 设计项目经理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/noah_levin.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;8-design-tools-will-make-a-designer-out-of-everyone&quot;&gt;8. Design tools will make a designer out of everyone&lt;/h1&gt;
&lt;h1 id=&quot;8-设计工具能让每个人都成为设计师&quot;&gt;8. 设计工具能让每个人都成为设计师&lt;/h1&gt;

&lt;p&gt;“Modern design tools will become approachable enough that more people will be able to contribute to the design process on a level-playing field. We’ll think of “designers” less as an isolated role, but as a thing many people contribute to.”
“现代设计工具将变得足够容易接近，更多的人将能够在公平竞争的环境中为设计过程做出贡献。 我们不会把“设计师”看作是一个孤立的角色，而是许多人为之贡献的东西。”&lt;/p&gt;

&lt;p&gt;Noah Levin, Design Manager at Figma
诺亚 · 莱文，Figma 设计经理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/zachary_gibson.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;9-jason-schwartzman-said-it-best&quot;&gt;9. Jason Schwartzman said it best&lt;/h1&gt;
&lt;h1 id=&quot;9-詹森舒瓦兹曼说的最好&quot;&gt;9. 詹森·舒瓦兹曼说的最好&lt;/h1&gt;

&lt;p&gt;“Can I quote I Heart Huckabees? The interconnection thing is definitely for real.”
“我可以引用笑看人心的话吗? 互连这件事绝对是真的。”&lt;/p&gt;

&lt;p&gt;Zachary Gibson, Material Design Creative Lead at Google
扎卡里 · 吉布森，谷歌材料设计创意主管&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/nicole_tollefson.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;10-time-to-check-your-ego-at-the-door&quot;&gt;10. Time to check your ego at the door&lt;/h1&gt;
&lt;h1 id=&quot;10-是时候在门口检查一下你的自负了&quot;&gt;10. 是时候在门口检查一下你的自负了&lt;/h1&gt;

&lt;p&gt;“We’ve given the word “empathy” a lot of deserving fanfare in the last few years, and next we’ll need to add to that rally-cry with ‘ego-less.’ Many still find it uncomfortable to invite “non-designers” into their headspace and discover that their best design is ultimately 90% (or more) other peoples’ input and 10% (or less) their own ideas, but the most successful teams and companies have known this about design for a long time.”
“在过去的几年里，我们已经为“同理心”这个词大张旗鼓地宣传了很多次，接下来，我们需要用“没有自我”来加强这种集会式的呐喊 许多人仍然觉得邀请“非设计师”进入他们的思维空间并发现他们最好的设计最终是90% (或更多)其他人的投入和10% (或更少)他们自己的想法是不舒服的，但是最成功的团队和公司早就知道这一点。”&lt;/p&gt;

&lt;p&gt;Nicole Tollefson, Lead Designer at Atlassian Buyer Experience
Nicole Tollefson，Atlassian 采购经验的首席设计师&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/josh_silverman.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;11-people-skills-will-matter-more-than-ever&quot;&gt;11. People skills will matter more than ever&lt;/h1&gt;
&lt;h1 id=&quot;11-人际交往技巧将比以往任何时候都重要&quot;&gt;11. 人际交往技巧将比以往任何时候都重要&lt;/h1&gt;

&lt;p&gt;“It’s becoming increasingly critical to hone our people skills — the stuff that persists amidst so much change. This means we’ll listen and collaborate more with each other; ensure diverse, cross-team voices are present and heard throughout our work; and cultivate optimal environments for optimal performance. Underneath every tech problem is a people problem.”
“磨练我们的人际交往技能变得越来越重要——这些技能在如此多的变化中依然存在。 这意味着我们将更多地相互倾听和协作; 确保不同的、跨团队的声音在整个工作过程中都能被听到; 培养最佳的工作环境。 每个技术问题的背后都有一个人的问题。”&lt;/p&gt;

&lt;p&gt;Josh Silverman, Design Producer at Twitter
乔什 · 西尔弗曼，Twitter 设计制作人&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/linda_dong.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;12-its-time-to-dynamically-react-to-the-environment&quot;&gt;12. It’s time to dynamically react to the environment&lt;/h1&gt;
&lt;h1 id=&quot;12-是时候对环境做出动态反应了&quot;&gt;12. 是时候对环境做出动态反应了&lt;/h1&gt;

&lt;p&gt;“I see future designs integrating the real world in a big way. Whether that’s through hardware sensors, alternate reality, or context-driven UI — designers will understand design lives outside of a screen. Designs will dynamically react to the environment around them and will take full advantage of hardware capabilities.”
“我预见未来的设计将以一种很大的方式整合现实世界。 无论是通过硬件传感器、虚拟现实还是上下文驱动的用户界面ーー设计师都将理解屏幕之外的设计世界。 设计将根据周围的环境动态地做出反应，并充分利用硬件功能。”&lt;/p&gt;

&lt;p&gt;Linda Dong, Design Manager at Lyft
设计经理 Linda Dong&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/lucas_smith.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;13-better-design-tools-will-lead-to-better-branding-through-design-systems&quot;&gt;13. Better design tools will lead to better branding through design systems&lt;/h1&gt;
&lt;h1 id=&quot;13-更好的设计工具将通过设计系统带来更好的品牌&quot;&gt;13. 更好的设计工具将通过设计系统带来更好的品牌&lt;/h1&gt;

&lt;p&gt;“As tooling catches up to the prevailing winds of design systems, it will be easier to collaborate and evolve the expression of a brand through a design system. This will allow designers to work at a higher fidelity earlier in the product process — improving decision making and lowering the cost to produce great digital work.”&lt;/p&gt;

&lt;p&gt;Lucas Smith, Design Technologist at Airbnb
卢卡斯 · 史密斯，Airbnb 设计技术专家&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/daniel_eden.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;14-design-systems-will-serve-people-not-products&quot;&gt;14. Design systems will serve people, not products&lt;/h1&gt;
&lt;h1 id=&quot;14-设计系统将服务于人而不是产品&quot;&gt;14. 设计系统将服务于人，而不是产品&lt;/h1&gt;

&lt;p&gt;“The next monumental shift in design requires us to think of design systems as a service and not a product. We tend to think of a design system as a “product serving products,” but I think that does a disservice to the relationships, negotiation, compromise, and human interaction that makes working on systems so challenging and rewarding.”
“设计的下一个重大转变要求我们把设计系统看作是一种服务，而不是一种产品。 我们倾向于认为设计系统是一个“为产品服务的产品” ，但是我认为这对人际关系、谈判、妥协和人际交往是有害的，而这些使得系统的工作变得如此具有挑战性和回报性。”&lt;/p&gt;

&lt;p&gt;Daniel Eden, Product Designer at Facebook
丹尼尔 · 伊登，Facebook 产品设计师&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/jerel_johnson.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;15-design-systems-will-only-grow-in-importance&quot;&gt;15. Design systems will only grow in importance&lt;/h1&gt;
&lt;h1 id=&quot;15-设计系统只会变得越来越重要&quot;&gt;15. 设计系统只会变得越来越重要&lt;/h1&gt;

&lt;p&gt;“We will continue to see the rise of design systems in response to scaling design teams, templatization, and increased reliance on machine learning and AI-based content. Designers will add procedural literacy and algorithmic thinking to their skillsets to meet the needs and manifest the desires of people.”
“我们将继续看到设计系统的崛起，以应对缩放设计团队、模板化、以及对机器学习和基于 ai 的内容的更多依赖。 设计师将在他们的技能中加入程序素养和算法思维，以满足人们的需求和实现人们的愿望。”&lt;/p&gt;

&lt;p&gt;Jerel Johnson, Sr. Product Designer at Backpack Health
背包健康公司高级产品设计师杰瑞尔 · 约翰逊&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/una_kravets.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;16-flat-design-will-no-longer-be-a-focus&quot;&gt;16. Flat design will no longer be a focus&lt;/h1&gt;
&lt;h1 id=&quot;16-扁平化设计将不再是焦点&quot;&gt;16. 扁平化设计将不再是焦点&lt;/h1&gt;

&lt;p&gt;“I think we’ll see a lot more creativity in interfaces in the coming year as we move away from flat design, with interaction and accessibility in mind.”
“我认为，随着我们逐渐远离扁平化设计，将交互性和可访问性考虑在内，未来一年我们将在界面上看到更多的创造力。”&lt;/p&gt;

&lt;p&gt;Una Kravets, Sr. UI Engineer at DigitalOcean
Una Kravets DigitalOcean 的高级 UI 工程师&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/isha_kasliwal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;17-design-systems-will-bridge-the-gap-across-departments&quot;&gt;17. Design systems will bridge the gap across departments&lt;/h1&gt;
&lt;h1 id=&quot;17-设计系统将弥合各部门之间的差距&quot;&gt;17. 设计系统将弥合各部门之间的差距&lt;/h1&gt;

&lt;p&gt;“Design trends for the next year will definitely include, just like this year, an uptick in design systems. More and more companies are learning the benefits of systemizing design, especially how it bridges the gaps between product, design, and engineering. Also, I feel like 3D modeling and 3D visualizations are continuing to grow in popularity. I can imagine showing depth in UI will be trendy as a result of that.”
“明年的设计趋势肯定会包括，就像今年一样，设计系统的上升。 越来越多的公司正在学习系统化设计的好处，尤其是它如何在产品、设计和工程之间搭建桥梁。 此外，我觉得3 d 建模和3 d 可视化正在持续增长的普及。 我可以想象在 UI 中显示深度将会成为时尚的结果。”&lt;/p&gt;

&lt;p&gt;Isha Kasliwal, Senior UI/UX Designer/Developer at Twitch
Isha Kasliwal，Twitch 高级 ui / ux 设计师 / 开发人员&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/translate/miriam_suzanne.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;18-improvements-in-css-will-affect-web-design-in-surprising-ways&quot;&gt;18. Improvements in CSS will affect web design in surprising ways&lt;/h1&gt;
&lt;h1 id=&quot;18-css-的改进会以令人惊讶的方式影响网页设计&quot;&gt;18. CSS 的改进会以令人惊讶的方式影响网页设计&lt;/h1&gt;

&lt;p&gt;“There’s a lot to be excited about in CSS — integrating new tools, like Grid and Custom Properties, with existing features like Calc and Viewport Units. Modern CSS allow a new level of interaction, responsiveness, and data-visualization that previously required extensive Javascript involvement. I’m excited to see what new trends grow out of that technology.”
“在 CSS 中有很多令人兴奋的东西ーー集成新的工具，如 Grid 和 Custom Properties，以及现有的特性，如 Calc 和 Viewport Units。 现代 CSS 允许一个新的层次的交互、响应和数据可视化，以前需要大量的 Javascript 参与。 我很高兴看到这项技术带来了什么新的趋势。”&lt;/p&gt;

&lt;p&gt;Miriam Suzanne, Designer and Developer at OddBird
米里亚姆苏珊娜，OddBird 的设计师和开发人员&lt;/p&gt;

&lt;p&gt;An honorary mention goes to… 
获得荣誉提名的是..&lt;/p&gt;</content><author><name>true</name></author><category term="翻译" /><category term="UI/UX" /><category term="designers" /><summary type="html">18位设计师预测2018年用户界面/用户体验趋势</summary></entry><entry><title type="html">MATLAB学习笔记</title><link href="http://localhost:4000/2019/08/06/matlab-Learning-notes.html" rel="alternate" type="text/html" title="MATLAB学习笔记" /><published>2019-08-06T02:24:44+08:00</published><updated>2019-08-06T02:24:44+08:00</updated><id>http://localhost:4000/2019/08/06/matlab-Learning-notes</id><content type="html" xml:base="http://localhost:4000/2019/08/06/matlab-Learning-notes.html">&lt;p&gt;&lt;img src=&quot;../assets/blogImg/201908051827.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;本文是matlab官网教程的学习记录笔记&quot;&gt;本文是MATLAB官网教程的学习记录笔记&lt;/h2&gt;

&lt;h4 id=&quot;11命令&quot;&gt;1.1命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clear 用于删除工作区变量，clc 用于清除命令行窗口。

MATLAB 包含内置的常量，例如 pi 表示 π

MATLAB 包含许多内置的函数，例如 abs（计算绝对值）和 eig（计算特征值）sqrt（计算平方根）。 &amp;lt;!--more--&amp;gt;
MATLAB 变量命名为符合以下规则的任何名称：以字母开头，并且仅包含字母、数字和下划线 (_)。

您可以使用方括号创建包含多个元素的数组。
&amp;gt;&amp;gt; x = [3 5]
x = 
    3    5


当您用空格（或逗号）分隔数值时，MATLAB 会将这些数值组合为一个行向量，行向量是一个包含一行多列的数组 (1×n)。当您用分号分隔数值时，MATLAB 会创建一个列向量 (n×1)
&amp;gt;&amp;gt; x = [1;3]。


您可以组合使用空格和分号来创建矩阵，即包含多行多列的数组。输入矩阵时，您必须逐行输入它们。
&amp;gt;&amp;gt; x = [3 4 5;6 7 8]
x = 
    3    4    5
    6    7    8

在 MATLAB 中，您可以在方括号内执行计算。
&amp;gt;&amp;gt; x = [abs(-4) 4^2]
x = 
 	    4    16

对于长向量，输入单个数值是不实际的。可用来创建等间距向量的替代便捷方法是使用 : 运算符并仅指定起始值和最终值：	first:last。
&amp;gt;&amp;gt; y = 5:8
y = 
    5    6    7    8


: 运算符使用默认的间距 1，但是您可以指定您自己的间距，如下所示。
&amp;gt;&amp;gt; x = 20:2:26
x = 
    20    22    24    26

如果您知道向量中所需的元素数目（而不是每个元素之间的间距），则可以改用 linspace 函数：linspace	(first,last,number_of_elements)。注意，请使用逗号 (,) 分隔 linspace 函数的输入。
&amp;gt;&amp;gt; x = linspace(0,1,5)
x = 
    0    0.250    0.500    0.750    1.000


linspace 和 : 运算符都可创建行向量。但是，您可以使用转置运算符 (') 将行向量转换为列向量。
&amp;gt;&amp;gt; x = 1:3;
&amp;gt;&amp;gt; x = x'
x = 
    1
    2
    3


您可以通过在一条命令中创建行向量并将其全部转置来创建列向量。注意此处使用圆括号来指定运算的顺序。
&amp;gt;&amp;gt; x = (1:2:5)'
x = 
    1
    3
    5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;linspace
https://www.mathworks.cn/help/matlab/ref/linspace.html&lt;/p&gt;

&lt;p&gt;3.3 数组创建函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;许多矩阵创建函数允许您输入一个数值来创建方阵 (n×n)，或者输入两个数值来创建非方阵。
&amp;gt;&amp;gt; x = rand(2)
x = 
    0.8147    0.1270
 	   0.9058    0.9134    
&amp;gt;&amp;gt; x = rand(2,3)
x = 
    0.6324    0.2785    0.9575
    0.0975    0.5469    0.9649
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.1 保存和加载变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;您可以使用 save 命令将工作区中的变量保存到称为 MAT 文件的 MATLAB 特定格式文件中。
  &amp;gt;&amp;gt; save foo x
以上命令将名为 x 的变量保存到名为 foo.mat 的 MAT 文件中。

您可以使用 load 命令从 MAT 文件加载变量。
&amp;gt;&amp;gt; load foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;附加资源：保存、加载和删除工作区变量 
https://www.mathworks.cn/help/matlab/matlab_env/save-load-and-delete-workspace-variables.html&lt;/p&gt;

&lt;p&gt;5.1 对数组进行索引&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;您可以使用行、列索引从数组中提取值。
&amp;gt;&amp;gt; x = A(5,7);
此语法将会提取 A 的第 5 行第 7 列的值，然后将结果赋给变量 x。	


您可以使用 MATLAB 关键字 end，作为行或列索引来引用最后一个元素。
&amp;gt;&amp;gt; x = A(end,2);

请注意，您可以将算术运算与关键字 end 结合使用。例如：
&amp;gt;&amp;gt; x = A(end-1,end-2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.2 提取多个元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;用作索引时，冒号运算符 (:) 可指代该维度中的所有元素。以下语法
&amp;gt;&amp;gt; x = A(2,:)
会创建一个包含 A 中第 2 行上所有元素的行向量。


冒号运算符可以引用某个值范围。以下语法会创建一个包含矩阵 A 的第 1 行、第 2 行和第 3 行所有元素的矩阵。
&amp;gt;&amp;gt; x = A(1:3,:)

单个索引值可用于引用向量元素。例如，以下语句
&amp;gt;&amp;gt; x = v(3)
会返回向量 v 的第 3 个元素（当 v 为行向量或列向量时）。

单个索引值范围可用于引用向量元素的子集。例如 
&amp;gt;&amp;gt; x = v(3:end)
返回向量 v 的一个子集，其中包含从第三个到最后一个元素范围内的所有元素
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;附加资源：矩阵索引 | 数组索引
https://www.mathworks.cn/help/matlab/math/array-indexing.html
https://www.mathworks.com/help/matlab/learn_matlab/array-indexing.html&lt;/p&gt;

&lt;p&gt;5.3 更改数组中的值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;记住您可以使用 : 字符来提取整列数据。

可以通过组合使用索引与赋值来修改变量的元素。
A(2,5) = 11
将 data 的第一行最后一列的值更改为 0.5。
&amp;gt;&amp;gt;data(1,end)=0.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.1 执行数组运算&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MATLAB 的设计让您能够自然地处理数组。例如，您可以将一个标量值与数组中的所有元素相加。
&amp;gt;&amp;gt; y = x + 2

您可以将任意两个大小相同的数组相加。
&amp;gt;&amp;gt; z = x + y

您可以将数组中的所有元素与某个标量相乘或相除。
&amp;gt;&amp;gt; z = 2*x
&amp;gt;&amp;gt; y = x/3

MATLAB 中的基本统计函数可应用于某个向量以生成单个输出。可以使用 max 函数来确定向量的最大值。
&amp;gt;&amp;gt; xMax = max(x)

MATLAB 的函数可在单个命令中对整个向量或值数组执行数学运算。
&amp;gt;&amp;gt; xSqrt = sqrt(x)
使用 round 函数创建一个名为 vr 的变量，其中包含四舍五入为整数的平均体积 va
vr=round(va)


* 运算符执行矩阵乘法。因此，如果您使用 * 将两个大小相同的向量相乘，则由于内部维度不一致，您将会收到一条错误消息。
&amp;gt;&amp;gt; z = [3 4] * [10 20]
用于矩阵乘法的维度不正确。请检查并确保第一个矩阵中的列数与第二个矩阵中的行数匹配。要执行按元素相乘，请使用 '.*'。
而 .* 运算符执行按元素乘法，允许您将两个大小相同的数组的对应元素相乘。
&amp;gt;&amp;gt; z = [3 4] .* [10 20]
z = 
    30    80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;附加资源：数组与矩阵运算
https://ww2.mathworks.cn/help/matlab/matlab_prog/array-vs-matrix-operations.html&lt;/p&gt;

&lt;p&gt;7.1 从函数调用获取多个输出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;size 函数可以应用于数组，以生成包含数组大小的单个输出变量。
&amp;gt;&amp;gt; s = size(x)

size 函数可以应用于矩阵，以生成单个输出变量或两个输出变量。使用方括号 ([ ]) 获取多个输出。
&amp;gt;&amp;gt; [xrow,xcol] = size(x)

可以使用 max 函数确定向量的最大值及其对应的索引值。max 函数的第一个输出为输入向量的最大值。执行带两个输出的调用时，第二个输出为索引值。
&amp;gt;&amp;gt; [xMax,idx] = max(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.1 绘制向量图&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;可以使用 plot 函数在一张图上绘制两个相同长度的向量。
&amp;gt;&amp;gt; plot(x,y)

plot 函数接受一个附加参数，该参数让您能够在单引号中使用各种符号来指定颜色、线型和标记样式。
&amp;gt;&amp;gt; plot(x,y,'r--o')
以上命令将会绘制一条红色 (r) 虚线 (--)，并使用圆圈 (o) 作为标记。您可以在线条设定的文档中了解有关可用符号的详细信息。https://ww2.mathworks.cn/help/matlab/ref/linespec.html

您会注意到，最开始创建的绘图消失了。要在一张图上先后绘制两条线，请使用 hold on 命令保留之前的绘图，然后添加另一条线。您也可以使用 hold off 命令返回到默认行为。

close all 命令以关闭所有打开的图窗窗口。

当您单独绘制一个向量时，MATLAB 会使用向量值作为 y 轴数据，并将 x 轴数据的范围设置为从 1 到 n（向量中的元素数目）。

plot 函数接受可选的附加输入，这些输入由一个属性名称和一个关联的值组成。
&amp;gt;&amp;gt; plot(y,'LineWidth',5)
以上命令将绘制一条粗线。您可以在 Line 属性文档中了解更多可用属性的详细信息。 https://www.mathworks.com/help/matlab/ref/matlab.graphics.chart.primitive.line-properties.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.2 编写绘图注释&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;可以使用绘图注释函数（例如 title）在绘图中添加标签。这些函数的输入是一个字符串。MATLAB 中的字符串是用单引号 (') 引起来的。
&amp;gt;&amp;gt; title('Plot Title')	

使用 ylabel 函数添加y轴标签
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>true</name></author><category term="MATLAB" /><category term="学习笔记" /><summary type="html"></summary></entry></feed>